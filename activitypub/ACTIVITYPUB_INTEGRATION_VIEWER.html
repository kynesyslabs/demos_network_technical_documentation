<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ActivityPub Integration - Interactive Diagram Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
        }

        header p {
            font-size: 1.2em;
            opacity: 0.95;
        }

        .navigation {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 30px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
            justify-content: center;
        }

        .nav-btn {
            padding: 12px 24px;
            background: white;
            border: 2px solid #667eea;
            color: #667eea;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: 600;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .nav-btn:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .nav-btn.active {
            background: #667eea;
            color: white;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .content {
            padding: 40px;
        }

        .diagram-section {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        .diagram-section.active {
            display: block;
        }

        .diagram-section h2 {
            color: #2d3748;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 3px solid #667eea;
        }

        .diagram-section p {
            color: #4a5568;
            font-size: 1.1em;
            line-height: 1.8;
            margin-bottom: 30px;
        }

        .mermaid {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            display: flex;
            justify-content: center;
            border: 1px solid #e2e8f0;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .key-points {
            background: #f7fafc;
            border-left: 4px solid #667eea;
            padding: 20px;
            margin: 30px 0;
            border-radius: 4px;
        }

        .key-points h3 {
            color: #2d3748;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .key-points ul {
            list-style-position: inside;
            color: #4a5568;
            line-height: 1.8;
        }

        .key-points li {
            margin: 8px 0;
        }

        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 30px;
            font-size: 0.95em;
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 1.8em;
            }

            .navigation {
                padding: 20px;
            }

            .nav-btn {
                padding: 10px 16px;
                font-size: 0.85em;
            }

            .content {
                padding: 20px;
            }

            .diagram-section h2 {
                font-size: 1.5em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ActivityPub Integration</h1>
            <p>Comprehensive Diagram Viewer - Federated Social Networking Protocol</p>
        </header>

        <nav class="navigation">
            <button class="nav-btn active" onclick="showDiagram(1)">1. Architecture Overview</button>
            <button class="nav-btn" onclick="showDiagram(2)">2. Actor Model</button>
            <button class="nav-btn" onclick="showDiagram(3)">3. Storage Schema</button>
            <button class="nav-btn" onclick="showDiagram(4)">4. REST API</button>
            <button class="nav-btn" onclick="showDiagram(5)">5. Object Model</button>
            <button class="nav-btn" onclick="showDiagram(6)">6. Message Flow</button>
            <button class="nav-btn" onclick="showDiagram(7)">7. Federation Protocol</button>
            <button class="nav-btn" onclick="showDiagram(8)">8. Collection Mgmt</button>
            <button class="nav-btn" onclick="showDiagram(9)">9. Data Persistence</button>
            <button class="nav-btn" onclick="showDiagram(10)">10. Complete Lifecycle</button>
        </nav>

        <div class="content">
            <!-- Diagram 1: Architecture Overview -->
            <section id="diagram-1" class="diagram-section active">
                <h2>1. ActivityPub Architecture Overview</h2>
                <p>
                    This diagram shows the complete architecture of the ActivityPub integration, including the Express.js server layer,
                    SQLite storage with 14 collections, ActivityStreams protocol support, and the universal REST API for collection access.
                </p>
                <div class="mermaid">
graph TB
    subgraph "ActivityPub Integration Layer"
        AP[ActivityPub Server]
        FS[FediStore SQLite]
        FT[FediTypes Interfaces]
    end

    subgraph "Express.js Server"
        Router[Express Router]
        GET[GET /:collection/:id]
        PUT[PUT /:collection/:id]
        GETALL[GET /:collection]
    end

    subgraph "Storage Layer"
        DB[(SQLite Database)]
        Tables[Collections Tables]
        Indices[Indexes & Keys]
    end

    subgraph "ActivityStreams Protocol"
        Context[@context: activitystreams]
        Objects[ActivityPub Objects]
        Activities[Activities]
    end

    subgraph "Collections"
        Actors[Actors]
        Objects2[Objects]
        Activities2[Activities]
        Inboxes[Inboxes]
        Outboxes[Outboxes]
        Followers[Followers]
        Following[Following]
        Liked[Liked]
        Collections2[Collections]
        Blocked[Blocked]
        Rejections[Rejections]
        Rejecteds[Rejecteds]
        Shares[Shares]
        Likes[Likes]
    end

    AP --> Router
    Router --> GET
    Router --> PUT
    Router --> GETALL

    AP --> FS
    FS --> DB
    DB --> Tables
    Tables --> Actors
    Tables --> Objects2
    Tables --> Activities2
    Tables --> Inboxes
    Tables --> Outboxes
    Tables --> Followers
    Tables --> Following
    Tables --> Liked
    Tables --> Collections2
    Tables --> Blocked
    Tables --> Rejections
    Tables --> Rejecteds
    Tables --> Shares
    Tables --> Likes

    FT --> Context
    Context --> Objects
    Context --> Activities

    GET --> FS
    PUT --> FS
    GETALL --> FS

    style AP fill:#e1f5ff
    style FS fill:#fff4e1
    style DB fill:#e8f5e9
    style Context fill:#f3e5f5
                </div>
                <div class="key-points">
                    <h3>Key Architectural Components</h3>
                    <ul>
                        <li><strong>Express.js Server</strong>: REST API with universal collection handlers (GET/PUT/GETALL)</li>
                        <li><strong>SQLite Storage</strong>: 14 normalized tables for ActivityPub data persistence</li>
                        <li><strong>ActivityStreams Protocol</strong>: Full @context support with standard vocabulary</li>
                        <li><strong>Collections</strong>: Actors, Objects, Activities, Inboxes, Outboxes, social interactions</li>
                        <li><strong>Type System</strong>: TypeScript interfaces for ActivityPub objects (feditypes.ts)</li>
                    </ul>
                </div>
            </section>

            <!-- Diagram 2: Actor Model & Collections -->
            <section id="diagram-2" class="diagram-section">
                <h2>2. Actor Model & Collections</h2>
                <p>
                    This class diagram illustrates the TypeScript type hierarchy for ActivityPub objects, showing how Actor, Collection,
                    Activity, and Note types extend the base ActivityPubObject interface, with relationships and properties defined.
                </p>
                <div class="mermaid">
classDiagram
    class ActivityPubObject {
        +string @context
        +string type
        +string id
        +string actor
        +string object
    }

    class Actor {
        +string name
        +string inbox
        +string outbox
        +string followers
        +string following
        +string liked
        +string preferredUsername
        +string summary
        +PublicKey publicKey
    }

    class PublicKey {
        +string id
        +string owner
        +string publicKeyPem
    }

    class Collection {
        +string type "Collection"
        +number totalItems
        +array items
        +string first
        +string last
    }

    class OrderedCollection {
        +string type "OrderedCollection"
        +number totalItems
        +array orderedItems
        +string first
        +string last
    }

    class Activity {
        +string type
        +string actor
        +string object
        +string target
        +string to
        +string cc
        +string published
    }

    class Note {
        +string type "Note"
        +string attributedTo
        +string content
        +string published
        +string to
        +string cc
        +string inReplyTo
    }

    ActivityPubObject <|-- Actor
    ActivityPubObject <|-- Collection
    ActivityPubObject <|-- Activity
    ActivityPubObject <|-- Note
    Collection <|-- OrderedCollection
    Actor --> PublicKey
    Activity --> Actor : references
    Note --> Actor : attributedTo

    note for Actor "Represents federated users\nwith inbox/outbox endpoints"
    note for Collection "Container for multiple\nActivityPub objects"
    note for Activity "Actions performed by actors\n(Create, Follow, Like, etc.)"
                </div>
                <div class="key-points">
                    <h3>Actor Model Features</h3>
                    <ul>
                        <li><strong>ActivityPubObject</strong>: Base interface with @context, type, id, actor, object</li>
                        <li><strong>Actor</strong>: Represents federated users with inbox/outbox endpoints and public keys</li>
                        <li><strong>Collection</strong>: Container for multiple ActivityPub objects with pagination support</li>
                        <li><strong>Activity</strong>: Actions performed by actors (Create, Follow, Like, Accept, etc.)</li>
                        <li><strong>Note</strong>: Content objects with HTML/text, attribution, and reply threading</li>
                        <li><strong>PublicKey</strong>: Cryptographic identity for HTTP signature verification</li>
                    </ul>
                </div>
            </section>

            <!-- Diagram 3: SQLite Storage Schema -->
            <section id="diagram-3" class="diagram-section">
                <h2>3. SQLite Storage Schema</h2>
                <p>
                    This entity-relationship diagram shows the complete SQLite database schema with 14 tables, their fields,
                    relationships, and foreign key constraints for maintaining data integrity in the ActivityPub storage layer.
                </p>
                <div class="mermaid">
erDiagram
    ACTORS {
        TEXT id PK
        TEXT type
        TEXT name
        TEXT inbox
        TEXT outbox
        TEXT followers
        TEXT following
        TEXT liked
    }

    OBJECTS {
        TEXT id PK
        TEXT type
        TEXT attributedTo
        TEXT content
    }

    ACTIVITIES {
        TEXT id PK
        TEXT type
        TEXT actor
        TEXT object
    }

    INBOXES {
        TEXT id PK
        TEXT owner
        TEXT content
    }

    OUTBOXES {
        TEXT id PK
        TEXT owner
        TEXT content
    }

    FOLLOWERS {
        TEXT id PK
        TEXT owner
        TEXT actor
    }

    FOLLOWINGS {
        TEXT id PK
        TEXT owner
        TEXT actor
    }

    LIKEDS {
        TEXT id PK
        TEXT owner
        TEXT object
    }

    COLLECTIONS {
        TEXT id PK
        TEXT owner
        TEXT items
    }

    BLOCKEDS {
        TEXT id PK
        TEXT owner
        TEXT actor
    }

    REJECTIONS {
        TEXT id PK
        TEXT owner
        TEXT activity
    }

    REJECTEDS {
        TEXT id PK
        TEXT owner
        TEXT activity
    }

    SHARES {
        TEXT id PK
        TEXT owner
        TEXT object
    }

    LIKES {
        TEXT id PK
        TEXT owner
        TEXT object
    }

    ACTORS ||--o{ INBOXES : "owner"
    ACTORS ||--o{ OUTBOXES : "owner"
    ACTORS ||--o{ FOLLOWERS : "owner"
    ACTORS ||--o{ FOLLOWINGS : "owner"
    ACTORS ||--o{ LIKEDS : "owner"
    ACTORS ||--o{ BLOCKEDS : "owner"
    ACTORS ||--o{ COLLECTIONS : "owner"
                </div>
                <div class="key-points">
                    <h3>Storage Schema Details</h3>
                    <ul>
                        <li><strong>Actors Table</strong>: Stores user profiles with inbox/outbox URLs and public keys</li>
                        <li><strong>Objects Table</strong>: Stores content (Notes, Articles) with attribution and threading</li>
                        <li><strong>Activities Table</strong>: Stores actions (Create, Follow, Like) with actor/object references</li>
                        <li><strong>Inboxes/Outboxes</strong>: Junction tables linking actors to received/sent activities</li>
                        <li><strong>Social Collections</strong>: Followers, Followings, Likeds, Blockeds, Shares, Likes</li>
                        <li><strong>Foreign Keys</strong>: Maintain referential integrity across all tables</li>
                    </ul>
                </div>
            </section>

            <!-- Diagram 4: REST API Endpoints -->
            <section id="diagram-4" class="diagram-section">
                <h2>4. REST API Endpoints</h2>
                <p>
                    This sequence diagram demonstrates the universal REST API handlers for collection operations: GET single item,
                    PUT item, GET all items, and error handling with Express.js routing to SQLite storage.
                </p>
                <div class="mermaid">
sequenceDiagram
    participant Client
    participant ExpressApp as Express.js Server
    participant Router as API Router
    participant Storage as ActivityPubStorage
    participant SQLite as SQLite DB

    Note over ExpressApp: Server listening on port 3000

    rect rgb(200, 220, 240)
        Note over Client,SQLite: GET Single Item Flow
        Client->>ExpressApp: GET /:collection/:id
        ExpressApp->>Router: Route to handler
        Router->>Storage: getItem(collection, id)
        Storage->>SQLite: SELECT * FROM collection WHERE id=?
        SQLite-->>Storage: Return row
        Storage-->>Router: Return item object
        Router-->>Client: 200 OK with JSON
    end

    rect rgb(220, 240, 200)
        Note over Client,SQLite: PUT Item Flow
        Client->>ExpressApp: PUT /:collection/:id + JSON body
        ExpressApp->>Router: Route to handler
        Router->>Router: Parse req.body
        Router->>Storage: saveItem(collection, req.body)
        Storage->>SQLite: INSERT INTO collection(id, data) VALUES(?, ?)
        SQLite-->>Storage: Confirm insert
        Storage-->>Router: Success callback
        Router-->>Client: 200 OK "Saved"
    end

    rect rgb(240, 220, 200)
        Note over Client,SQLite: GET Collection Flow
        Client->>ExpressApp: GET /:collection
        ExpressApp->>Router: Route to handler
        Router->>Storage: getAllItems(collection)
        Storage->>SQLite: SELECT * FROM collection
        SQLite-->>Storage: Return all rows
        Storage-->>Router: Return items array
        Router-->>Client: 200 OK with JSON array
    end

    rect rgb(240, 200, 220)
        Note over Client,Router: Error Handling
        Client->>ExpressApp: GET /invalid/unknown
        ExpressApp->>Router: Route to handler
        Router->>Storage: getItem('invalid', 'unknown')
        Storage-->>Router: Callback with null
        Router-->>Client: 404 Not Found
    end
                </div>
                <div class="key-points">
                    <h3>REST API Features</h3>
                    <ul>
                        <li><strong>Universal Handlers</strong>: GET/:collection/:id, PUT/:collection/:id, GET/:collection</li>
                        <li><strong>Dynamic Routing</strong>: Collection name as URL parameter (actors, objects, activities, etc.)</li>
                        <li><strong>CRUD Operations</strong>: Create/Replace (PUT), Read (GET), List (GET collection)</li>
                        <li><strong>Error Handling</strong>: 404 Not Found for missing items, 500 for database errors</li>
                        <li><strong>JSON Format</strong>: All requests/responses use application/json content-type</li>
                        <li><strong>Port 3000</strong>: Express.js server listens on port 3000 for ActivityPub endpoints</li>
                    </ul>
                </div>
            </section>

            <!-- Diagram 5: ActivityStreams Object Model -->
            <section id="diagram-5" class="diagram-section">
                <h2>5. ActivityStreams Object Model</h2>
                <p>
                    This diagram shows the ActivityStreams vocabulary structure, including core object types (Person, Note, Image),
                    activity types (Create, Follow, Like), collection types, and the properties that define ActivityPub objects.
                </p>
                <div class="mermaid">
graph TB
    subgraph "ActivityStreams Context"
        Context["@context: https://www.w3.org/ns/activitystreams"]
    end

    subgraph "Core Object Types"
        Person[Person/Actor]
        Note[Note/Article]
        Image[Image/Document]
        Video[Video]
        Audio[Audio]
    end

    subgraph "Activity Types"
        Create[Create Activity]
        Follow[Follow Activity]
        Like[Like Activity]
        Announce[Announce/Share]
        Delete[Delete Activity]
        Update[Update Activity]
        Accept[Accept Activity]
        Reject[Reject Activity]
        Block[Block Activity]
    end

    subgraph "Collection Types"
        OrderedColl[OrderedCollection]
        CollPage[CollectionPage]
        OrderedPage[OrderedCollectionPage]
    end

    subgraph "Properties"
        ID[id: unique URI]
        Type[type: object type]
        Actor[actor: performing entity]
        Object[object: target entity]
        Target[target: destination]
        To[to: primary recipients]
        CC[cc: copied recipients]
        Published[published: timestamp]
        Content[content: HTML/text]
    end

    Context --> Person
    Context --> Note
    Context --> Image
    Context --> Create
    Context --> Follow
    Context --> Like
    Context --> OrderedColl

    Create --> ID
    Create --> Type
    Create --> Actor
    Create --> Object
    Create --> To
    Create --> CC
    Create --> Published

    Note --> Content
    Note --> Actor
    Note --> Published

    Person --> OrderedColl
    OrderedColl --> CollPage
    OrderedColl --> OrderedPage

    style Context fill:#f3e5f5
    style Create fill:#e1f5ff
    style Person fill:#fff4e1
    style OrderedColl fill:#e8f5e9
                </div>
                <div class="key-points">
                    <h3>ActivityStreams Vocabulary</h3>
                    <ul>
                        <li><strong>@context</strong>: https://www.w3.org/ns/activitystreams for JSON-LD namespace</li>
                        <li><strong>Core Objects</strong>: Person/Actor (users), Note (posts), Image/Video/Audio (media)</li>
                        <li><strong>Activities</strong>: Create, Follow, Like, Announce, Delete, Update, Accept, Reject, Block</li>
                        <li><strong>Collections</strong>: OrderedCollection for inbox/outbox with pagination support</li>
                        <li><strong>Properties</strong>: id (URI), type, actor, object, target, to/cc (recipients), published</li>
                        <li><strong>Content</strong>: HTML or plain text with sanitization and Markdown support</li>
                    </ul>
                </div>
            </section>

            <!-- Diagram 6: Inbox/Outbox Message Flow -->
            <section id="diagram-6" class="diagram-section">
                <h2>6. Inbox/Outbox Message Flow</h2>
                <p>
                    This sequence diagram illustrates the complete message flow for outbound activities (posting to remote servers)
                    and inbound activities (receiving from remote servers), including HTTP signature verification and delivery.
                </p>
                <div class="mermaid">
sequenceDiagram
    participant LocalActor as Local Actor
    participant Outbox as Outbox
    participant LocalServer as Local ActivityPub Server
    participant RemoteServer as Remote ActivityPub Server
    participant Inbox as Remote Inbox
    participant RemoteActor as Remote Actor

    rect rgb(200, 220, 240)
        Note over LocalActor,RemoteActor: Outbound Activity Flow
        LocalActor->>LocalActor: Create Activity (e.g., Note)
        LocalActor->>LocalServer: POST /outbox with Activity
        LocalServer->>LocalServer: Validate Activity
        LocalServer->>LocalServer: Add @context, id, published
        LocalServer->>Outbox: Save to outboxes table
        LocalServer->>LocalServer: Determine recipients (to, cc)
        LocalServer->>RemoteServer: HTTP POST to remote inbox
        RemoteServer->>RemoteServer: Verify HTTP signature
        RemoteServer->>Inbox: Save to inboxes table
        RemoteServer->>RemoteActor: Deliver to local recipient
        RemoteServer-->>LocalServer: 202 Accepted
    end

    rect rgb(220, 240, 200)
        Note over LocalActor,RemoteActor: Inbound Activity Flow
        RemoteActor->>RemoteActor: Create Activity
        RemoteActor->>RemoteServer: POST to outbox
        RemoteServer->>LocalServer: HTTP POST to /inbox
        LocalServer->>LocalServer: Verify HTTP signature
        LocalServer->>LocalServer: Validate Activity structure
        LocalServer->>Inbox: Save to inboxes table
        LocalServer->>LocalActor: Deliver notification
        LocalServer-->>RemoteServer: 202 Accepted
    end

    rect rgb(240, 220, 200)
        Note over LocalActor,Outbox: Retrieve Activities
        LocalActor->>LocalServer: GET /outbox
        LocalServer->>Outbox: Query outboxes table
        Outbox-->>LocalServer: Return OrderedCollection
        LocalServer-->>LocalActor: Return activities list
    end
                </div>
                <div class="key-points">
                    <h3>Message Flow Details</h3>
                    <ul>
                        <li><strong>Outbound Flow</strong>: Local actor creates activity → save to outbox → federate to remote inboxes</li>
                        <li><strong>Inbound Flow</strong>: Remote server posts to local inbox → verify signature → save → deliver</li>
                        <li><strong>HTTP Signatures</strong>: Cryptographic verification using actor's publicKeyPem</li>
                        <li><strong>202 Accepted</strong>: Asynchronous processing with immediate acknowledgment</li>
                        <li><strong>Recipient Addressing</strong>: Parse to/cc fields to determine delivery targets</li>
                        <li><strong>OrderedCollection</strong>: Inbox/outbox returned as paginated collections</li>
                    </ul>
                </div>
            </section>

            <!-- Diagram 7: Federation Protocol -->
            <section id="diagram-7" class="diagram-section">
                <h2>7. Federation Protocol</h2>
                <p>
                    This state machine shows the complete federation protocol flow from actor discovery through WebFinger lookup,
                    public key verification, activity creation with HTTP signatures, and inbox delivery with retry logic.
                </p>
                <div class="mermaid">
stateDiagram-v2
    [*] --> ActorDiscovery: Remote actor mention

    ActorDiscovery --> WebFingerLookup: Query actor identifier
    WebFingerLookup --> FetchActorProfile: Get actor URL
    FetchActorProfile --> VerifyPublicKey: Retrieve publicKey

    VerifyPublicKey --> CreateActivity: Actor verified
    VerifyPublicKey --> [*]: Verification failed

    CreateActivity --> SignRequest: Generate HTTP signature
    SignRequest --> DeliverToInbox: POST to remote inbox

    DeliverToInbox --> ReceiveResponse: 202 Accepted
    DeliverToInbox --> RetryDelivery: Network error
    DeliverToInbox --> PermanentFailure: 4xx/5xx error

    RetryDelivery --> DeliverToInbox: Exponential backoff
    RetryDelivery --> PermanentFailure: Max retries exceeded

    ReceiveResponse --> UpdateFollowerStatus: Follow/Accept activity
    ReceiveResponse --> StoreRemoteActivity: Other activities

    UpdateFollowerStatus --> [*]
    StoreRemoteActivity --> [*]
    PermanentFailure --> [*]

    state DeliverToInbox {
        [*] --> ValidateURL
        ValidateURL --> SignHeaders
        SignHeaders --> HTTPPost
        HTTPPost --> [*]
    }

    state CreateActivity {
        [*] --> GenerateID
        GenerateID --> AddContext
        AddContext --> SetTimestamp
        SetTimestamp --> AddRecipients
        AddRecipients --> [*]
    }

    note right of VerifyPublicKey
        Public key verification
        using actor's publicKeyPem
    end note

    note right of SignRequest
        HTTP Signature header
        with (request-target), host,
        date, digest
    end note
                </div>
                <div class="key-points">
                    <h3>Federation Protocol Features</h3>
                    <ul>
                        <li><strong>Actor Discovery</strong>: WebFinger lookup for actor@domain identifiers</li>
                        <li><strong>Public Key Verification</strong>: Retrieve and verify actor's publicKeyPem</li>
                        <li><strong>Activity Creation</strong>: Generate unique ID, add @context, set timestamp, add recipients</li>
                        <li><strong>HTTP Signatures</strong>: Sign (request-target), host, date, digest headers</li>
                        <li><strong>Inbox Delivery</strong>: POST to remote inbox URL with signed headers</li>
                        <li><strong>Retry Logic</strong>: Exponential backoff for network errors, max retries before failure</li>
                        <li><strong>Response Handling</strong>: 202 Accepted for success, update follower status for Follow/Accept</li>
                    </ul>
                </div>
            </section>

            <!-- Diagram 8: Collection Management Operations -->
            <section id="diagram-8" class="diagram-section">
                <h2>8. Collection Management Operations</h2>
                <p>
                    This comprehensive flowchart shows all collection management operations for the 8 primary collections:
                    Followers, Following, Liked, Inbox, Outbox, Blocked, Shares, and Likes, with add/remove logic and federation.
                </p>
                <div class="mermaid">
flowchart TD
    Start([Collection Operation Request]) --> CheckType{Collection Type?}

    CheckType -->|Followers| FollowerOps[Follower Operations]
    CheckType -->|Following| FollowingOps[Following Operations]
    CheckType -->|Liked| LikedOps[Liked Operations]
    CheckType -->|Inbox| InboxOps[Inbox Operations]
    CheckType -->|Outbox| OutboxOps[Outbox Operations]
    CheckType -->|Blocked| BlockedOps[Blocked Operations]
    CheckType -->|Shares| SharesOps[Shares Operations]
    CheckType -->|Likes| LikesOps[Likes Operations]

    FollowerOps --> AddFollower{Add or Remove?}
    AddFollower -->|Add| InsertFollower[INSERT INTO followers]
    AddFollower -->|Remove| DeleteFollower[DELETE FROM followers]
    InsertFollower --> UpdateFollowerCount[Update totalItems count]
    DeleteFollower --> UpdateFollowerCount

    FollowingOps --> AddFollowing{Add or Remove?}
    AddFollowing -->|Add| InsertFollowing[INSERT INTO followings]
    AddFollowing -->|Remove| DeleteFollowing[DELETE FROM followings]
    InsertFollowing --> UpdateFollowingCount[Update totalItems count]
    DeleteFollowing --> UpdateFollowingCount

    LikedOps --> AddLike{Add or Remove?}
    AddLike -->|Add| InsertLiked[INSERT INTO likeds]
    AddLike -->|Remove| DeleteLiked[DELETE FROM likeds]
    InsertLiked --> UpdateLikedCount[Update totalItems count]
    DeleteLiked --> UpdateLikedCount

    InboxOps --> ReceiveActivity[Receive Activity]
    ReceiveActivity --> ValidateActivity{Valid Activity?}
    ValidateActivity -->|Yes| InsertInbox[INSERT INTO inboxes]
    ValidateActivity -->|No| RejectActivity[Return 400 Bad Request]
    InsertInbox --> NotifyActor[Notify local actor]

    OutboxOps --> PublishActivity[Publish Activity]
    PublishActivity --> GenerateID[Generate unique ID]
    GenerateID --> InsertOutbox[INSERT INTO outboxes]
    InsertOutbox --> FederateActivity[Federate to remote servers]

    BlockedOps --> BlockUser{Block or Unblock?}
    BlockUser -->|Block| InsertBlocked[INSERT INTO blockeds]
    BlockUser -->|Unblock| DeleteBlocked[DELETE FROM blockeds]
    InsertBlocked --> FilterContent[Filter blocked content]
    DeleteBlocked --> RemoveFilter[Remove content filter]

    SharesOps --> ShareObject[Share Object]
    ShareObject --> CreateAnnounce[Create Announce activity]
    CreateAnnounce --> InsertShare[INSERT INTO shares]
    InsertShare --> FederateAnnounce[Federate Announce]

    LikesOps --> LikeObject[Like Object]
    LikeObject --> CreateLike[Create Like activity]
    CreateLike --> InsertLike[INSERT INTO likes]
    InsertLike --> FederateLike[Federate Like]

    UpdateFollowerCount --> Success([Operation Complete])
    UpdateFollowingCount --> Success
    UpdateLikedCount --> Success
    NotifyActor --> Success
    FederateActivity --> Success
    FilterContent --> Success
    RemoveFilter --> Success
    FederateAnnounce --> Success
    FederateLike --> Success
    RejectActivity --> Failure([Operation Failed])

    style Start fill:#e1f5ff
    style Success fill:#c8e6c9
    style Failure fill:#ffcdd2
    style CheckType fill:#fff9c4
    style ValidateActivity fill:#fff9c4
                </div>
                <div class="key-points">
                    <h3>Collection Operations</h3>
                    <ul>
                        <li><strong>Followers</strong>: Add/remove followers, update totalItems count, manage acceptance status</li>
                        <li><strong>Following</strong>: Add/remove following relationships, track accepted/pending</li>
                        <li><strong>Liked</strong>: Add/remove liked objects, track published timestamp</li>
                        <li><strong>Inbox</strong>: Receive and validate activities, notify local actors</li>
                        <li><strong>Outbox</strong>: Publish activities, generate IDs, federate to remote servers</li>
                        <li><strong>Blocked</strong>: Block/unblock users, filter blocked content</li>
                        <li><strong>Shares</strong>: Create Announce activities, federate shares</li>
                        <li><strong>Likes</strong>: Create Like activities, federate likes</li>
                    </ul>
                </div>
            </section>

            <!-- Diagram 9: Data Persistence & Retrieval -->
            <section id="diagram-9" class="diagram-section">
                <h2>9. Data Persistence & Retrieval</h2>
                <p>
                    This sequence diagram shows the complete data persistence lifecycle from database initialization with table creation
                    through CRUD operations (save, get, getAll, delete) and database closure, with SQLite file system interactions.
                </p>
                <div class="mermaid">
sequenceDiagram
    participant App as Application
    participant Storage as ActivityPubStorage
    participant DB as SQLite Database
    participant FS as File System

    rect rgb(200, 220, 240)
        Note over App,FS: Initialization Flow
        App->>Storage: new ActivityPubStorage(dbPath)
        Storage->>DB: new sqlite3.Database(dbPath)
        DB->>FS: Open/Create database file
        FS-->>DB: Database handle
        DB-->>Storage: Database connection
        Storage->>Storage: createTables()
        Storage->>DB: CREATE TABLE IF NOT EXISTS actors...
        Storage->>DB: CREATE TABLE IF NOT EXISTS objects...
        Storage->>DB: CREATE TABLE IF NOT EXISTS activities...
        Storage->>DB: CREATE TABLE IF NOT EXISTS inboxes...
        Storage->>DB: CREATE TABLE IF NOT EXISTS outboxes...
        Storage->>DB: CREATE TABLE IF NOT EXISTS followers...
        Storage->>DB: CREATE TABLE IF NOT EXISTS followings...
        Storage->>DB: CREATE TABLE IF NOT EXISTS likeds...
        Storage->>DB: CREATE TABLE IF NOT EXISTS blockeds...
        Storage->>DB: CREATE TABLE IF NOT EXISTS rejections...
        Storage->>DB: CREATE TABLE IF NOT EXISTS shares...
        Storage->>DB: CREATE TABLE IF NOT EXISTS likes...
        DB-->>Storage: Tables created
    end

    rect rgb(220, 240, 200)
        Note over App,DB: Save Item Flow
        App->>Storage: saveItem(collection, id, item)
        Storage->>Storage: Serialize item to JSON
        Storage->>Storage: Extract fields from item
        Storage->>DB: INSERT OR REPLACE INTO collection
        DB->>DB: Execute prepared statement
        DB-->>Storage: Success/Error
        Storage-->>App: Callback(error)
    end

    rect rgb(240, 220, 200)
        Note over App,DB: Get Single Item Flow
        App->>Storage: getItem(collection, id, callback)
        Storage->>DB: SELECT * FROM collection WHERE id=?
        DB->>DB: Execute query
        DB-->>Storage: Return row or null
        Storage->>Storage: Deserialize row to object
        Storage-->>App: Callback(item)
    end

    rect rgb(240, 240, 200)
        Note over App,DB: Get All Items Flow
        App->>Storage: getAllItems(collection, callback)
        Storage->>DB: SELECT * FROM collection
        DB->>DB: Execute query
        DB-->>Storage: Return rows array
        Storage->>Storage: Map rows to objects
        Storage-->>App: Callback(items[])
    end

    rect rgb(220, 220, 240)
        Note over App,DB: Delete Item Flow
        App->>Storage: deleteItem(collection, id, callback)
        Storage->>DB: DELETE FROM collection WHERE id=?
        DB->>DB: Execute delete
        DB-->>Storage: Rows affected
        Storage-->>App: Callback(error)
    end

    rect rgb(240, 200, 200)
        Note over Storage,FS: Close Database
        App->>Storage: close()
        Storage->>DB: db.close()
        DB->>FS: Close file handle
        FS-->>DB: Closed
        DB-->>Storage: Closed
    end
                </div>
                <div class="key-points">
                    <h3>Data Persistence Features</h3>
                    <ul>
                        <li><strong>Initialization</strong>: Create SQLite database, initialize 14 tables with proper schemas</li>
                        <li><strong>Save Operations</strong>: INSERT with JSON blob storage for items</li>
                        <li><strong>Get Operations</strong>: SELECT with WHERE clause, deserialize row to object</li>
                        <li><strong>Get All Operations</strong>: SELECT all rows, map array to objects</li>
                        <li><strong>Delete Operations</strong>: DELETE with WHERE clause, return affected row count</li>
                        <li><strong>Database Closure</strong>: Proper cleanup with db.close() on shutdown</li>
                        <li><strong>File System</strong>: SQLite file stored at configurable dbPath</li>
                    </ul>

            </section>

            <!-- Diagram 10: Complete ActivityPub Lifecycle -->
            <section id="diagram-10" class="diagram-section">
                <h2>10. Complete ActivityPub Lifecycle</h2>
                <p>
                    This comprehensive state machine shows the complete ActivityPub lifecycle from server initialization through actor creation,
                    outbound/inbound activities, follow workflows, social interactions, collection queries, and graceful shutdown.
                </p>
                <div class="mermaid">
stateDiagram-v2
    [*] --> ServerInit: Initialize ActivityPub Server

    ServerInit --> DatabaseSetup: Create SQLite storage
    DatabaseSetup --> TableCreation: Create all collections tables
    TableCreation --> ExpressStartup: Start Express.js server
    ExpressStartup --> ListeningState: Server listening on port 3000

    ListeningState --> ActorCreation: User creates actor
    ActorCreation --> StoreActor: Save actor to actors table
    StoreActor --> InitCollections: Initialize empty collections
    InitCollections --> ActorReady: Actor ready for federation

    ActorReady --> OutboundActivity: Actor creates content
    ActorReady --> InboundActivity: Receive remote activity

    state OutboundActivity {
        [*] --> CreateObject: Create Note/Article
        CreateObject --> CreateActivity: Wrap in Create activity
        CreateActivity --> SaveOutbox: Save to outboxes table
        SaveOutbox --> DetermineRecipients: Parse to/cc fields
        DetermineRecipients --> FederateRemote: POST to remote inboxes
        FederateRemote --> [*]
    }

    state InboundActivity {
        [*] --> ReceiveHTTP: Receive HTTP POST
        ReceiveHTTP --> VerifySignature: Verify HTTP signature
        VerifySignature --> ValidateStructure: Validate ActivityStreams
        ValidateStructure --> ProcessActivity: Determine activity type
        ProcessActivity --> SaveInbox: Save to inboxes table
        SaveInbox --> UpdateCollections: Update relevant collections
        UpdateCollections --> NotifyUser: Notify local actor
        NotifyUser --> [*]
    }

    OutboundActivity --> ActorReady: Activity sent
    InboundActivity --> ActorReady: Activity processed

    ActorReady --> FollowWorkflow: Follow/Accept flow

    state FollowWorkflow {
        [*] --> SendFollow: Send Follow activity
        SendFollow --> WaitAccept: Wait for Accept/Reject
        WaitAccept --> ReceiveAccept: Receive Accept
        WaitAccept --> ReceiveReject: Receive Reject
        ReceiveAccept --> AddFollowing: Add to followings table
        ReceiveReject --> RemoveRequest: Clean up request
        AddFollowing --> [*]
        RemoveRequest --> [*]
    }

    FollowWorkflow --> ActorReady: Follow complete

    ActorReady --> InteractionFlow: Like/Announce/Reply

    state InteractionFlow {
        [*] --> ChooseAction: Select interaction type
        ChooseAction --> LikeAction: Like object
        ChooseAction --> AnnounceAction: Announce/Share
        ChooseAction --> ReplyAction: Reply to object

        LikeAction --> CreateLike: Create Like activity
        CreateLike --> SaveLike: Save to likes table
        SaveLike --> FederateLike: Send to object author

        AnnounceAction --> CreateAnnounce: Create Announce activity
        CreateAnnounce --> SaveShare: Save to shares table
        SaveShare --> FederateAnnounce: Send to followers

        ReplyAction --> CreateNote: Create Note object
        CreateNote --> SetInReplyTo: Set inReplyTo property
        SetInReplyTo --> FederateReply: Send to participants

        FederateLike --> [*]
        FederateAnnounce --> [*]
        FederateReply --> [*]
    }

    InteractionFlow --> ActorReady: Interaction complete

    ActorReady --> QueryCollections: GET collection

    state QueryCollections {
        [*] --> IdentifyCollection: Parse collection name
        IdentifyCollection --> QueryDB: SELECT from table
        QueryDB --> FormatResponse: Format as OrderedCollection
        FormatResponse --> ReturnJSON: Return JSON response
        ReturnJSON --> [*]
    }

    QueryCollections --> ActorReady: Query complete

    ActorReady --> Shutdown: Server shutdown
    Shutdown --> CloseDatabase: Close SQLite connection
    CloseDatabase --> StopExpress: Stop Express server
    StopExpress --> [*]

    note right of ServerInit
        Initialize with SQLite path
        Create ActivityPubStorage instance
    end note

    note right of ActorReady
        Central state - actor can
        send/receive activities,
        manage collections
    end note

    note right of FollowWorkflow
        Federation handshake
        between local and remote actors
    end note

    note right of InteractionFlow
        Social interactions
        (Like, Share, Reply)
    end note
                </div>
                <div class="key-points">
                    <h3>Complete Lifecycle Overview</h3>
                    <ul>
                        <li><strong>Initialization</strong>: Server startup → SQLite setup → table creation → Express.js listening</li>
                        <li><strong>Actor Creation</strong>: Store actor → initialize empty collections → ready for federation</li>
                        <li><strong>Outbound Activities</strong>: Create content → wrap in activity → save to outbox → federate</li>
                        <li><strong>Inbound Activities</strong>: Receive POST → verify signature → validate → save to inbox → notify</li>
                        <li><strong>Follow Workflow</strong>: Send Follow → wait for Accept/Reject → update followings table</li>
                        <li><strong>Interactions</strong>: Like/Announce/Reply → create activity → save to collection → federate</li>
                        <li><strong>Collection Queries</strong>: Parse collection name → query database → format as OrderedCollection</li>
                        <li><strong>Shutdown</strong>: Close database connection → stop Express server → graceful exit</li>
                    </ul>
                </div>
            </section>
        </div>

        <footer>
            <p><strong>ActivityPub Integration</strong> - Comprehensive Diagram Documentation</p>
            <p>10 Detailed Mermaid Diagrams Covering Express.js Server, SQLite Storage, ActivityStreams Protocol, and Federation</p>
            <p>Files: feditypes.ts | fediverse.ts | fedistore.ts</p>
        </footer>
    </div>

    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            securityLevel: 'loose',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            },
            sequence: {
                useMaxWidth: true,
                wrap: true,
                width: 150
            },
            stateDiagram: {
                useMaxWidth: true
            },
            er: {
                useMaxWidth: true
            },
            class: {
                useMaxWidth: true
            }
        });

        function showDiagram(num) {
            // Hide all sections
            const sections = document.querySelectorAll('.diagram-section');
            sections.forEach(section => {
                section.classList.remove('active');
            });

            // Remove active class from all buttons
            const buttons = document.querySelectorAll('.nav-btn');
            buttons.forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected section
            document.getElementById('diagram-' + num).classList.add('active');

            // Add active class to clicked button
            event.target.classList.add('active');

            // Scroll to top of content
            document.querySelector('.content').scrollIntoView({ behavior: 'smooth' });
        }
    </script>
</body>
</html>
