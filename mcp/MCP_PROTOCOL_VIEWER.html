<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCP Protocol - Interactive Diagram Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
        }

        header p {
            font-size: 1.2em;
            opacity: 0.95;
        }

        .navigation {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 30px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
            justify-content: center;
        }

        .nav-btn {
            padding: 12px 24px;
            background: white;
            border: 2px solid #667eea;
            color: #667eea;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: 600;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .nav-btn:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .nav-btn.active {
            background: #667eea;
            color: white;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .content {
            padding: 40px;
        }

        .diagram-section {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        .diagram-section.active {
            display: block;
        }

        .diagram-section h2 {
            color: #2d3748;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 3px solid #667eea;
        }

        .diagram-section p {
            color: #4a5568;
            font-size: 1.1em;
            line-height: 1.8;
            margin-bottom: 30px;
        }

        .mermaid {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            display: flex;
            justify-content: center;
            border: 1px solid #e2e8f0;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .key-points {
            background: #f7fafc;
            border-left: 4px solid #667eea;
            padding: 20px;
            margin: 30px 0;
            border-radius: 4px;
        }

        .key-points h3 {
            color: #2d3748;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .key-points ul {
            list-style-position: inside;
            color: #4a5568;
            line-height: 1.8;
        }

        .key-points li {
            margin: 8px 0;
        }

        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 30px;
            font-size: 0.95em;
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 1.8em;
            }

            .navigation {
                padding: 20px;
            }

            .nav-btn {
                padding: 10px 16px;
                font-size: 0.85em;
            }

            .content {
                padding: 20px;
            }

            .diagram-section h2 {
                font-size: 1.5em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>MCP (Model Context Protocol)</h1>
            <p>Comprehensive Diagram Viewer - AI Assistant Integration for Blockchain Operations</p>
        </header>

        <nav class="navigation">
            <button class="nav-btn active" onclick="showDiagram(1)">1. Architecture</button>
            <button class="nav-btn" onclick="showDiagram(2)">2. Class Structure</button>
            <button class="nav-btn" onclick="showDiagram(3)">3. Transport Layer</button>
            <button class="nav-btn" onclick="showDiagram(4)">4. Tool Lifecycle</button>
            <button class="nav-btn" onclick="showDiagram(5)">5. Request Handling</button>
            <button class="nav-btn" onclick="showDiagram(6)">6. SSE Server</button>
            <button class="nav-btn" onclick="showDiagram(7)">7. Demos Tools</button>
            <button class="nav-btn" onclick="showDiagram(8)">8. Tool Execution</button>
            <button class="nav-btn" onclick="showDiagram(9)">9. Error Handling</button>
            <button class="nav-btn" onclick="showDiagram(10)">10. Complete Lifecycle</button>
        </nav>

        <div class="content">
            <!-- Diagram 1: Architecture Overview -->
            <section id="diagram-1" class="diagram-section active">
                <h2>1. MCP Architecture Overview</h2>
                <p>
                    This diagram shows the complete architecture of the MCP (Model Context Protocol) integration, including the MCPServerManager,
                    MCP SDK components, dual transport support (stdio and SSE), Express.js layer for remote access, and Demos Network tool integration.
                </p>
                <div class="mermaid">
graph TB
    subgraph "MCP Integration Layer"
        Factory[createDemosMCPServer Factory]
        Manager[MCPServerManager]
        Config[MCPServerConfig]
    end

    subgraph "MCP SDK"
        Server[@modelcontextprotocol/sdk Server]
        StdioTransport[StdioServerTransport]
        SSETransport[SSEServerTransport]
        Schemas[Request Schemas]
    end

    subgraph "Transport Options"
        Stdio[Stdio Transport Local]
        SSE[SSE Transport Remote]
    end

    subgraph "Express.js Layer"
        ExpressApp[Express Application]
        CORSMiddleware[CORS Middleware]
        HTTPServer[HTTP Server]
        SSEEndpoint[GET /sse]
        MessageEndpoint[POST /message]
    end

    subgraph "Tool System"
        ToolMap[Tools Map]
        ToolRegistry[Tool Registration]
        ToolHandlers[Tool Handlers]
    end

    subgraph "Demos Network Tools"
        NetworkTools[Network Tools]
        BlockchainTools[Blockchain Tools]
        PeerTools[Peer Tools]
    end

    subgraph "Demos Network Integration"
        SharedState[getSharedState]
        PeerManager[PeerManager]
        ChainAPI[Chain API]
    end

    Factory --> Manager
    Manager --> Config
    Manager --> Server
    Manager --> ToolMap

    Server --> StdioTransport
    Server --> SSETransport
    Server --> Schemas

    StdioTransport --> Stdio
    SSETransport --> SSE

    SSE --> ExpressApp
    ExpressApp --> CORSMiddleware
    ExpressApp --> HTTPServer
    ExpressApp --> SSEEndpoint
    ExpressApp --> MessageEndpoint

    Manager --> ToolRegistry
    ToolRegistry --> ToolHandlers
    ToolHandlers --> NetworkTools
    ToolHandlers --> BlockchainTools
    ToolHandlers --> PeerTools

    NetworkTools --> SharedState
    BlockchainTools --> ChainAPI
    PeerTools --> PeerManager

    style Manager fill:#e1f5ff
    style Server fill:#fff4e1
    style ExpressApp fill:#e8f5e9
    style ToolMap fill:#f3e5f5
                </div>
                <div class="key-points">
                    <h3>Key Architectural Components</h3>
                    <ul>
                        <li><strong>MCPServerManager</strong>: Main class managing server lifecycle, tool registration, and client connections</li>
                        <li><strong>MCP SDK</strong>: @modelcontextprotocol/sdk providing Server, transport classes, and request schemas</li>
                        <li><strong>Dual Transport</strong>: stdio for local CLI clients, SSE for remote AI clients over HTTP</li>
                        <li><strong>Express.js Layer</strong>: HTTP server with CORS, GET /sse endpoint, POST /message endpoint</li>
                        <li><strong>Tool System</strong>: Map-based tool registry with Zod schema validation and async handlers</li>
                        <li><strong>Demos Network Tools</strong>: 7 tools across 3 categories (network, blockchain, peer)</li>
                        <li><strong>Integration</strong>: getSharedState for network status, Chain API for blockchain, PeerManager for peers</li>
                    </ul>
                </div>
            </section>

            <!-- Diagram 2: Class Structure -->
            <section id="diagram-2" class="diagram-section">
                <h2>2. MCP Server Class Structure</h2>
                <p>
                    This class diagram illustrates the TypeScript class structure for MCPServerManager (with tool management and lifecycle methods),
                    MCPServerConfig (server configuration), MCPTool (tool definition), and related types for server status and transport configuration.
                </p>
                <div class="mermaid">
classDiagram
    class MCPServerManager {
        -server: Server | null
        -transport: StdioServerTransport | SSEServerTransport | null
        -expressApp: express.Application | null
        -httpServer: http.Server | null
        -tools: Map~string, MCPTool~
        -isRunning: boolean
        -config: MCPServerConfig
        +constructor(config: MCPServerConfig)
        -initializeServer() void
        -setupServerHandlers() void
        -startStdioServer() Promise~void~
        -startSSEServer() Promise~void~
        +registerTool(tool: MCPTool) void
        +unregisterTool(toolName: string) void
        +start() Promise~void~
        +stop() Promise~void~
        +getStatus() ServerStatus
        +getRegisteredTools() string[]
        +shutdown() Promise~void~
    }

    class MCPServerConfig {
        +string name
        +string version
        +string description
        +Partial~ServerCapabilities~ capabilities
        +TransportConfig transport
    }

    class TransportConfig {
        +MCPTransportType type
        +number port
        +string host
    }

    class MCPTool {
        +string name
        +string description
        +z.ZodSchema inputSchema
        +Function handler
    }

    class DemosNetworkToolsConfig {
        +boolean enableBlockchainTools
        +boolean enableNetworkTools
        +boolean enablePeerTools
    }

    class ServerStatus {
        +boolean isRunning
        +number toolCount
        +string serverName
        +string serverVersion
    }

    MCPServerManager --> MCPServerConfig : uses
    MCPServerManager --> MCPTool : manages
    MCPServerConfig --> TransportConfig : contains
    MCPServerManager --> ServerStatus : returns

    note for MCPServerManager "Main server manager class\nHandles lifecycle and tools"
    note for MCPTool "Tool definition with\nZod schema validation"
    note for TransportConfig "stdio or sse\nwith port and host"
                </div>
                <div class="key-points">
                    <h3>Class Structure Details</h3>
                    <ul>
                        <li><strong>MCPServerManager</strong>: Main class with private fields for server, transport, Express app, HTTP server, tools Map</li>
                        <li><strong>Tool Registration</strong>: registerTool/unregisterTool methods that modify tools Map before server starts</li>
                        <li><strong>Lifecycle Methods</strong>: start() initializes and starts server, stop() closes all connections, shutdown() for graceful cleanup</li>
                        <li><strong>Private Methods</strong>: initializeServer, setupServerHandlers, startStdioServer, startSSEServer</li>
                        <li><strong>MCPServerConfig</strong>: name, version, description, capabilities (tools, resources, prompts, logging), transport config</li>
                        <li><strong>MCPTool</strong>: name, description, Zod inputSchema for validation, async handler function</li>
                        <li><strong>Transport Types</strong>: "stdio" for local, "sse" for remote with port/host configuration</li>
                    </ul>
                </div>
            </section>

            <!-- Diagram 3: Transport Layer -->
            <section id="diagram-3" class="diagram-section">
                <h2>3. Transport Layer (Stdio vs SSE)</h2>
                <p>
                    This flowchart shows the two transport options for MCP server: stdio transport for local CLI clients using stdin/stdout,
                    and SSE (Server-Sent Events) transport for remote AI clients over HTTP with Express.js server setup.
                </p>
                <div class="mermaid">
flowchart TB
    Start([MCP Server Start]) --> CheckTransport{Transport Type?}

    CheckTransport -->|stdio| StdioFlow[Stdio Transport Local]
    CheckTransport -->|sse| SSEFlow[SSE Transport Remote]

    subgraph "Stdio Transport Flow"
        StdioFlow --> CreateStdio[Create StdioServerTransport]
        CreateStdio --> ConnectStdio[server.connect transport]
        ConnectStdio --> StdioReady[Server ready for local connections]
        StdioReady --> StdioComm[Communication via stdin/stdout]
        StdioComm --> StdioNote[Used for local CLI clients]
    end

    subgraph "SSE Transport Flow"
        SSEFlow --> SSEConfig[Get port and host from config]
        SSEConfig --> CreateExpress[Create Express app]
        CreateExpress --> AddCORS[Add CORS middleware]
        AddCORS --> AddJSONMiddleware[Add express.json]
        AddJSONMiddleware --> CreateHTTP[Create HTTP server]
        CreateHTTP --> SetupSSEEndpoint[Setup GET /sse endpoint]
        SetupSSEEndpoint --> SetupMessageEndpoint[Setup POST /message endpoint]
        SetupMessageEndpoint --> SetSSEHeaders[Set SSE headers]
        SetSSEHeaders --> CreateSSETransport[Create SSEServerTransport]
        CreateSSETransport --> ConnectSSE[server.connect transport]
        ConnectSSE --> ListenHTTP[HTTP server listen port]
        ListenHTTP --> SSEReady[Server ready for remote connections]
        SSEReady --> SSEComm[Communication via HTTP SSE]
        SSEComm --> SSENote[Used for remote AI clients]
    end

    StdioNote --> Complete([Transport Ready])
    SSENote --> Complete

    style Start fill:#e1f5ff
    style Complete fill:#c8e6c9
    style CheckTransport fill:#fff9c4
    style StdioFlow fill:#e3f2fd
    style SSEFlow fill:#fff3e0
                </div>
                <div class="key-points">
                    <h3>Transport Layer Features</h3>
                    <ul>
                        <li><strong>Stdio Transport</strong>: For local CLI clients, uses stdin for input and stdout for output</li>
                        <li><strong>SSE Transport</strong>: For remote network clients (AI assistants), uses HTTP with Server-Sent Events</li>
                        <li><strong>Express.js Setup</strong>: SSE requires Express app with CORS, JSON middleware, HTTP server</li>
                        <li><strong>SSE Endpoints</strong>: GET /sse for SSE stream, POST /message for client-to-server messages</li>
                        <li><strong>SSE Headers</strong>: Content-Type: text/event-stream, Cache-Control: no-cache, Connection: keep-alive</li>
                        <li><strong>Default Config</strong>: stdio by default, SSE on port 3001 localhost when configured</li>
                    </ul>
                </div>
            </section>

            <!-- Diagram 4: Tool Lifecycle -->
            <section id="diagram-4" class="diagram-section">
                <h2>4. Tool Registration & Lifecycle</h2>
                <p>
                    This state machine shows the complete tool lifecycle from server creation through tool registration (before start),
                    server initialization, request handling (ListTools and CallTool), and graceful shutdown with cleanup.
                </p>
                <div class="mermaid">
stateDiagram-v2
    [*] --> ServerCreated: new MCPServerManager(config)

    ServerCreated --> RegisterTools: Register tools

    state RegisterTools {
        [*] --> CheckRunning: registerTool(tool)
        CheckRunning --> Running: Server running?
        Running --> [*]: Error: Cannot register
        CheckRunning --> AddToMap: Server not running
        AddToMap --> LogRegistration: tools.set(name, tool)
        LogRegistration --> [*]: Tool registered
    }

    RegisterTools --> MoreTools: More tools to register?
    MoreTools --> RegisterTools: Yes
    MoreTools --> ServerNotInitialized: No, start server

    ServerNotInitialized --> InitializeServer: initializeServer()

    state InitializeServer {
        [*] --> CreateServer: new Server(name, version)
        CreateServer --> SetCapabilities: Set capabilities
        SetCapabilities --> SetupHandlers: setupServerHandlers()
        SetupHandlers --> ListToolsHandler: Handle ListToolsRequest
        SetupHandlers --> CallToolHandler: Handle CallToolRequest
        ListToolsHandler --> [*]
        CallToolHandler --> [*]
    }

    InitializeServer --> CreateTransport: Server initialized

    state CreateTransport {
        [*] --> TransportType: Determine transport
        TransportType --> StdioTransport: stdio
        TransportType --> SSETransport: sse
        StdioTransport --> ConnectStdio: Connect transport
        SSETransport --> StartExpress: Start Express server
        StartExpress --> ConnectSSE: Connect transport
        ConnectStdio --> [*]
        ConnectSSE --> [*]
    }

    CreateTransport --> ServerRunning: isRunning = true

    ServerRunning --> HandleRequests: Ready for requests

    state HandleRequests {
        [*] --> WaitRequest: Wait for client request
        WaitRequest --> ListTools: ListToolsRequest
        WaitRequest --> CallTool: CallToolRequest

        ListTools --> BuildToolList: Build tool list from Map
        BuildToolList --> ReturnTools: Return tools array
        ReturnTools --> WaitRequest

        CallTool --> ValidateTool: Check if tool exists
        ValidateTool --> ExecuteTool: tool.handler(args)
        ExecuteTool --> ReturnResult: Return result
        ReturnResult --> WaitRequest
    }

    HandleRequests --> StopServer: stop() called

    state StopServer {
        [*] --> CheckRunning2: Check if running
        CheckRunning2 --> CloseServer: server.close()
        CloseServer --> CloseTransport: transport.close()
        CloseTransport --> CloseHTTP: Close HTTP server if SSE
        CloseHTTP --> ClearState: isRunning = false
        ClearState --> [*]
    }

    StopServer --> ServerStopped: Server stopped

    ServerStopped --> [*]: Shutdown complete

    note right of ServerCreated
        Tools can only be registered
        before server starts
    end note

    note right of HandleRequests
        Server handles requests
        from MCP clients
    end note

    note right of StopServer
        Graceful shutdown
        with cleanup
    end note
                </div>
                <div class="key-points">
                    <h3>Tool Lifecycle Details</h3>
                    <ul>
                        <li><strong>Tool Registration</strong>: Must happen before server starts, throws error if attempted while running</li>
                        <li><strong>Tools Map</strong>: Map<string, MCPTool> stores all registered tools by name</li>
                        <li><strong>Server Initialization</strong>: Creates MCP Server, sets capabilities, sets up request handlers</li>
                        <li><strong>Request Handlers</strong>: ListToolsRequestSchema (return tool list), CallToolRequestSchema (execute tool)</li>
                        <li><strong>Transport Creation</strong>: Stdio for local, SSE with Express for remote</li>
                        <li><strong>Request Handling</strong>: Loop waiting for requests, process, return results</li>
                        <li><strong>Graceful Shutdown</strong>: Close server → close transport → close HTTP (if SSE) → clear state</li>
                    </ul>
                </div>
            </section>

            <!-- Diagram 5: Request Handling -->
            <section id="diagram-5" class="diagram-section">
                <h2>5. Request Handling Flow</h2>
                <p>
                    This sequence diagram demonstrates the complete request handling flow for ListTools (returns tool list from Map)
                    and CallTool (validates with Zod, executes handler, queries Demos Network) with error handling for tool not found and validation failures.
                </p>
                <div class="mermaid">
sequenceDiagram
    participant Client as MCP Client
    participant Transport as Transport Layer
    participant Server as MCP Server
    participant Handler as Request Handler
    participant ToolMap as Tools Map
    participant Tool as Tool Handler
    participant Demos as Demos Network

    rect rgb(200, 220, 240)
        Note over Client,Demos: ListTools Request Flow
        Client->>Transport: ListToolsRequest
        Transport->>Server: Forward request
        Server->>Handler: Process ListToolsRequest
        Handler->>ToolMap: Get all tools
        ToolMap-->>Handler: Return tools Map
        Handler->>Handler: Build tool list
        loop For each tool
            Handler->>Handler: Extract name, description, inputSchema
        end
        Handler-->>Server: Return {tools: Tool[]}
        Server-->>Transport: Format response
        Transport-->>Client: Return tool list
    end

    rect rgb(220, 240, 200)
        Note over Client,Demos: CallTool Request Flow
        Client->>Transport: CallToolRequest {name, arguments}
        Transport->>Server: Forward request
        Server->>Handler: Process CallToolRequest
        Handler->>ToolMap: Get tool by name
        alt Tool not found
            ToolMap-->>Handler: null
            Handler-->>Server: Error: Tool not found
            Server-->>Client: Error response
        end
        ToolMap-->>Handler: Return MCPTool
        Handler->>Handler: Validate arguments with inputSchema
        alt Validation failed
            Handler-->>Server: Error: Invalid arguments
            Server-->>Client: Error response
        end
        Handler->>Tool: Execute tool.handler(validatedArgs)
        Tool->>Demos: Query Demos Network
        alt Network query
            Demos->>Demos: getSharedState / Chain.getLastBlock / etc
        end
        Demos-->>Tool: Return data
        Tool-->>Handler: Return result
        Handler->>Handler: Format result as {content: [{type: "text", text: JSON}]}
        Handler-->>Server: Return formatted result
        Server-->>Transport: Format response
        Transport-->>Client: Return result
    end

    rect rgb(240, 220, 200)
        Note over Client,Demos: Error Handling Flow
        Client->>Transport: CallToolRequest with invalid data
        Transport->>Server: Forward request
        Server->>Handler: Process request
        Handler->>Handler: Validate with Zod schema
        Handler-->>Server: ValidationError
        Server->>Server: Log error
        Server-->>Transport: Error response
        Transport-->>Client: Error with message
    end
                </div>
                <div class="key-points">
                    <h3>Request Handling Details</h3>
                    <ul>
                        <li><strong>ListTools</strong>: Iterate tools Map, extract name/description/inputSchema, return as Tool array</li>
                        <li><strong>CallTool</strong>: Get tool from Map, validate args with Zod, execute handler, format result</li>
                        <li><strong>Validation</strong>: Zod schema.parse(args) validates input against tool's inputSchema</li>
                        <li><strong>Tool Execution</strong>: Async handler queries Demos Network APIs (getSharedState, Chain, PeerManager)</li>
                        <li><strong>Result Format</strong>: {content: [{type: "text", text: JSON.stringify(result, null, 2)}]}</li>
                        <li><strong>Error Handling</strong>: Tool not found, validation errors, handler execution errors all return error responses</li>
                    </ul>
                </div>
            </section>

            <!-- Diagram 6: SSE Server Setup -->
            <section id="diagram-6" class="diagram-section">
                <h2>6. SSE Server Setup</h2>
                <p>
                    This sequence diagram shows the complete SSE server setup with Express.js, including initialization, endpoint configuration,
                    client connection flow (GET /sse), messaging (POST /message), client disconnect handling, and server shutdown.
                </p>
                <div class="mermaid">
sequenceDiagram
    participant Manager as MCPServerManager
    participant Express as Express App
    participant HTTP as HTTP Server
    participant Client as Remote Client
    participant SSE as SSEServerTransport
    participant MCP as MCP Server

    rect rgb(200, 220, 240)
        Note over Manager,MCP: SSE Server Initialization
        Manager->>Manager: startSSEServer()
        Manager->>Manager: Get port (3001) and host (localhost)
        Manager->>Express: express()
        Manager->>Express: app.use(cors())
        Manager->>Express: app.use(express.json())
        Manager->>HTTP: http.createServer(app)
        Manager->>HTTP: Store httpServer reference
    end

    rect rgb(220, 240, 200)
        Note over Manager,MCP: SSE Endpoint Setup
        Manager->>Express: app.get('/sse', handler)
        Manager->>Express: app.post('/message', handler)
        Manager->>HTTP: server.listen(port, host)
        HTTP-->>Manager: Server listening
        Manager->>Manager: Log SSE endpoints
    end

    rect rgb(240, 220, 200)
        Note over Client,MCP: Client Connection Flow
        Client->>HTTP: GET /sse
        HTTP->>Express: Route to /sse handler
        Express->>Express: Set SSE headers
        Express->>Express: Content-Type: text/event-stream
        Express->>Express: Cache-Control: no-cache
        Express->>Express: Connection: keep-alive
        Express->>Express: Access-Control-Allow-Origin: *
        Express->>SSE: new SSEServerTransport('/message', res)
        SSE->>MCP: server.connect(sseTransport)
        MCP-->>SSE: Connected
        SSE-->>Express: SSE stream established
        Express-->>Client: SSE connection open
    end

    rect rgb(240, 240, 200)
        Note over Client,MCP: Client Messaging Flow
        Client->>HTTP: POST /message with JSON
        HTTP->>Express: Route to /message handler
        Express->>Express: Parse JSON body
        Express->>SSE: Forward to SSEServerTransport
        SSE->>MCP: Process message
        MCP->>MCP: Handle request
        MCP-->>SSE: Response
        SSE-->>Client: Send via SSE stream
        Express-->>Client: 200 OK {status: "received"}
    end

    rect rgb(200, 240, 240)
        Note over Client,MCP: Client Disconnect Flow
        Client->>HTTP: Close connection
        HTTP->>Express: req.on('close')
        Express->>SSE: sseTransport.close()
        SSE->>MCP: Disconnect
        Express->>Express: Log: SSE client disconnected
    end

    rect rgb(240, 200, 220)
        Note over Manager,HTTP: Server Shutdown Flow
        Manager->>Manager: stop()
        Manager->>MCP: server.close()
        Manager->>SSE: transport.close()
        Manager->>HTTP: httpServer.close()
        HTTP-->>Manager: Server closed
        Manager->>Manager: isRunning = false
    end
                </div>
                <div class="key-points">
                    <h3>SSE Server Details</h3>
                    <ul>
                        <li><strong>Express Setup</strong>: CORS middleware for cross-origin, express.json() for body parsing</li>
                        <li><strong>HTTP Server</strong>: http.createServer(expressApp) wraps Express, listen on port 3001</li>
                        <li><strong>SSE Headers</strong>: text/event-stream, no-cache, keep-alive, CORS headers</li>
                        <li><strong>Client Connection</strong>: GET /sse establishes SSE stream, creates SSEServerTransport, connects to MCP Server</li>
                        <li><strong>Messaging</strong>: POST /message receives JSON, forwards to SSEServerTransport, response via SSE stream</li>
                        <li><strong>Disconnect Handling</strong>: req.on('close') event closes SSEServerTransport and logs</li>
                        <li><strong>Graceful Shutdown</strong>: Close MCP server → close transport → close HTTP server → clear state</li>
                    </ul>
                </div>
            </section>

            <!-- Diagram 7: Demos Network Tools -->
            <section id="diagram-7" class="diagram-section">
                <h2>7. Demos Network Tools</h2>
                <p>
                    This diagram shows the 7 Demos Network tools across 3 categories: Network Tools (status, identity),
                    Blockchain Tools (last block, block by number, chain height), Peer Tools (peer list, peer count),
                    and their integration with Demos Network APIs.
                </p>
                <div class="mermaid">
graph TB
    subgraph "Tool Factory"
        Factory[createDemosNetworkTools]
        Config[DemosNetworkToolsConfig]
    end

    subgraph "Network Tools"
        GetNetworkStatus[get_network_status]
        GetNodeIdentity[get_node_identity]
    end

    subgraph "Blockchain Tools"
        GetLastBlock[get_last_block]
        GetBlockByNumber[get_block_by_number]
        GetChainHeight[get_chain_height]
    end

    subgraph "Peer Tools"
        GetPeerList[get_peer_list]
        GetPeerCount[get_peer_count]
    end

    subgraph "Demos Network APIs"
        SharedState[getSharedState]
        ChainAPI[Chain API]
        PeerManager[PeerManager]
    end

    Factory --> Config
    Config --> |enableNetworkTools| NetworkToolsCreate[Create Network Tools]
    Config --> |enableBlockchainTools| BlockchainToolsCreate[Create Blockchain Tools]
    Config --> |enablePeerTools| PeerToolsCreate[Create Peer Tools]

    NetworkToolsCreate --> GetNetworkStatus
    NetworkToolsCreate --> GetNodeIdentity

    BlockchainToolsCreate --> GetLastBlock
    BlockchainToolsCreate --> GetBlockByNumber
    BlockchainToolsCreate --> GetChainHeight

    PeerToolsCreate --> GetPeerList
    PeerToolsCreate --> GetPeerCount

    GetNetworkStatus --> SharedState
    GetNodeIdentity --> SharedState

    GetLastBlock --> ChainAPI
    GetBlockByNumber --> ChainAPI
    GetChainHeight --> ChainAPI

    GetPeerList --> PeerManager
    GetPeerCount --> PeerManager

    SharedState --> StateData[serverPort, connectionString, signingAlgorithm, lastBlockNumber, lastBlockHash, rpcFee, identity, keypair]
    ChainAPI --> ChainData[getLastBlock, getBlockByNumber methods]
    PeerManager --> PeerData[getPeers method]

    style Factory fill:#e1f5ff
    style GetNetworkStatus fill:#fff4e1
    style GetLastBlock fill:#e8f5e9
    style GetPeerList fill:#f3e5f5
                </div>
                <div class="key-points">
                    <h3>Demos Network Tools</h3>
                    <ul>
                        <li><strong>Network Tools</strong>: get_network_status (server port, connection string, last block), get_node_identity (public key, IP)</li>
                        <li><strong>Blockchain Tools</strong>: get_last_block, get_block_by_number (with number param), get_chain_height</li>
                        <li><strong>Peer Tools</strong>: get_peer_list (full peer info), get_peer_count (just count)</li>
                        <li><strong>Configuration</strong>: DemosNetworkToolsConfig enables/disables tool categories (all enabled by default)</li>
                        <li><strong>getSharedState</strong>: Central state object with serverPort, connectionString, identity, keypair, last block info</li>
                        <li><strong>Chain API</strong>: Chain.getLastBlock(), Chain.getBlockByNumber(number) for blockchain queries</li>
                        <li><strong>PeerManager</strong>: PeerManager.getInstance().getPeers() for peer information</li>
                    </ul>
                </div>
            </section>

            <!-- Diagram 8: Tool Execution -->
            <section id="diagram-8" class="diagram-section">
                <h2>8. Tool Execution Flow</h2>
                <p>
                    This comprehensive flowchart shows the complete tool execution flow from client call through tool lookup,
                    Zod validation, handler execution for all 7 tools, Demos Network API queries, result formatting, and error handling.
                </p>
                <div class="mermaid">
flowchart TD
    Start([Client calls tool]) --> ReceiveRequest[Receive CallToolRequest]
    ReceiveRequest --> ExtractParams[Extract name and arguments]
    ExtractParams --> LookupTool[tools.get name]

    LookupTool --> CheckExists{Tool exists?}
    CheckExists -->|No| ErrorNotFound[Error: Tool not found]
    ErrorNotFound --> ReturnError1([Return error response])

    CheckExists -->|Yes| GetTool[Get MCPTool from Map]
    GetTool --> ValidateInput[Validate with inputSchema.parse]

    ValidateInput --> CheckValidation{Validation passed?}
    CheckValidation -->|No| ErrorValidation[Zod ValidationError]
    ErrorValidation --> ReturnError2([Return validation error])

    CheckValidation -->|Yes| ExecuteHandler[Execute tool.handler]

    ExecuteHandler --> ToolType{Tool Type?}

    ToolType -->|Network Status| NetworkHandler[get_network_status handler]
    ToolType -->|Node Identity| IdentityHandler[get_node_identity handler]
    ToolType -->|Last Block| LastBlockHandler[get_last_block handler]
    ToolType -->|Block By Number| BlockNumberHandler[get_block_by_number handler]
    ToolType -->|Chain Height| ChainHeightHandler[get_chain_height handler]
    ToolType -->|Peer List| PeerListHandler[get_peer_list handler]
    ToolType -->|Peer Count| PeerCountHandler[get_peer_count handler]

    NetworkHandler --> GetSharedState1[getSharedState]
    GetSharedState1 --> ReturnNetworkData[Return serverPort, connectionString, etc.]

    IdentityHandler --> GetSharedState2[getSharedState.identity]
    GetSharedState2 --> ReturnIdentityData[Return publicKey, publicIP]

    LastBlockHandler --> ChainGetLast[Chain.getLastBlock]
    ChainGetLast --> ReturnLastBlock[Return block data]

    BlockNumberHandler --> ChainGetByNum[Chain.getBlockByNumber args.blockNumber]
    ChainGetByNum --> CheckBlockExists{Block exists?}
    CheckBlockExists -->|No| ErrorBlockNotFound[Error: Block not found]
    CheckBlockExists -->|Yes| ReturnBlock[Return block data]

    ChainHeightHandler --> ChainGetHeight[Chain.getLastBlock]
    ChainGetHeight --> ReturnHeight[Return height and hash]

    PeerListHandler --> PeerGetList[PeerManager.getInstance.getPeers]
    PeerGetList --> MapPeers[Map peers to response format]
    MapPeers --> ReturnPeerList[Return peerCount and peers array]

    PeerCountHandler --> PeerGetCount[PeerManager.getInstance.getPeers]
    PeerGetCount --> CountPeers[Count peers.length]
    CountPeers --> ReturnPeerCount[Return peerCount]

    ReturnNetworkData --> FormatResult[Format as JSON]
    ReturnIdentityData --> FormatResult
    ReturnLastBlock --> FormatResult
    ReturnBlock --> FormatResult
    ReturnHeight --> FormatResult
    ReturnPeerList --> FormatResult
    ReturnPeerCount --> FormatResult

    ErrorBlockNotFound --> CatchError[Catch error]
    CatchError --> LogError[Log error]
    LogError --> ThrowError[Throw formatted error]
    ThrowError --> ReturnError3([Return error response])

    FormatResult --> LogSuccess[Log: Tool executed successfully]
    LogSuccess --> WrapContent[Wrap in {content: [{type: "text", text: JSON}]}]
    WrapContent --> ReturnSuccess([Return success response])

    style Start fill:#e1f5ff
    style ReturnSuccess fill:#c8e6c9
    style ReturnError1 fill:#ffcdd2
    style ReturnError2 fill:#ffcdd2
    style ReturnError3 fill:#ffcdd2
    style CheckExists fill:#fff9c4
    style CheckValidation fill:#fff9c4
    style CheckBlockExists fill:#fff9c4
                </div>
                <div class="key-points">
                    <h3>Tool Execution Details</h3>
                    <ul>
                        <li><strong>Tool Lookup</strong>: Get tool from Map by name, error if not found</li>
                        <li><strong>Zod Validation</strong>: inputSchema.parse(args) validates and transforms arguments</li>
                        <li><strong>Handler Execution</strong>: Async handler function executes with validated args</li>
                        <li><strong>Network Tools</strong>: Query getSharedState for server info, identity, keypair</li>
                        <li><strong>Blockchain Tools</strong>: Chain API for last block, block by number, chain height</li>
                        <li><strong>Peer Tools</strong>: PeerManager.getInstance().getPeers() for peer information</li>
                        <li><strong>Result Format</strong>: JSON.stringify with 2-space indentation, wrapped in {content: [{type: "text", text: ...}]}</li>
                        <li><strong>Error Handling</strong>: Tool not found, validation errors, handler errors all logged and returned</li>
                    </ul>
                </div>
            </section>

            <!-- Diagram 9: Error Handling -->
            <section id="diagram-9" class="diagram-section">
                <h2>9. Error Handling & Validation</h2>
                <p>
                    This sequence diagram demonstrates comprehensive error handling for tool not found errors, Zod validation errors,
                    handler execution errors, and network/API errors, with logging throughout and structured error responses to clients.
                </p>
                <div class="mermaid">
sequenceDiagram
    participant Client
    participant Server as MCP Server
    participant Handler as Request Handler
    participant Zod as Zod Validator
    participant Tool as Tool Handler
    participant Logger as Log System

    rect rgb(200, 220, 240)
        Note over Client,Logger: Tool Not Found Error
        Client->>Server: CallToolRequest {name: "invalid_tool"}
        Server->>Handler: Process request
        Handler->>Handler: tools.get("invalid_tool")
        Handler-->>Handler: Returns null
        Handler->>Logger: Log error
        Handler->>Handler: throw Error("Tool 'invalid_tool' not found")
        Handler-->>Server: Error
        Server-->>Client: Error response
    end

    rect rgb(220, 240, 200)
        Note over Client,Logger: Validation Error
        Client->>Server: CallToolRequest {name: "get_block_by_number", args: {blockNumber: "invalid"}}
        Server->>Handler: Process request
        Handler->>Handler: Get tool from Map
        Handler->>Zod: inputSchema.parse(args)
        Zod->>Zod: Validate against z.object({blockNumber: z.number().min(0)})
        Zod-->>Handler: ValidationError: Expected number, received string
        Handler->>Logger: Log validation error
        Handler->>Handler: throw Error("Tool execution failed: ...")
        Handler-->>Server: Error with message
        Server-->>Client: Error response
    end

    rect rgb(240, 220, 200)
        Note over Client,Logger: Handler Execution Error
        Client->>Server: CallToolRequest {name: "get_block_by_number", args: {blockNumber: 99999}}
        Server->>Handler: Process request
        Handler->>Handler: Get tool and validate
        Handler->>Tool: Execute handler
        Tool->>Tool: Chain.getBlockByNumber(99999)
        Tool-->>Tool: Block not found
        Tool->>Tool: throw Error("Block 99999 not found")
        Tool-->>Handler: Error
        Handler->>Logger: Log: Tool execution failed
        Handler->>Handler: Catch and format error
        Handler->>Handler: throw Error("Tool execution failed: Block 99999 not found")
        Handler-->>Server: Error
        Server-->>Client: Error response
    end

    rect rgb(240, 240, 200)
        Note over Client,Logger: Network/API Error
        Client->>Server: CallToolRequest {name: "get_last_block"}
        Server->>Handler: Process request
        Handler->>Tool: Execute handler
        Tool->>Tool: Chain.getLastBlock()
        alt Database connection error
            Tool-->>Tool: Database error
            Tool->>Logger: Log error
            Tool->>Tool: throw Error("Failed to get last block")
        end
        Tool-->>Handler: Error
        Handler->>Logger: Log: Tool execution failed
        Handler-->>Server: Error
        Server-->>Client: Error response with message
    end

    rect rgb(200, 240, 240)
        Note over Client,Logger: Success Case
        Client->>Server: CallToolRequest {name: "get_chain_height"}
        Server->>Handler: Process request
        Handler->>Handler: Get tool and validate
        Handler->>Tool: Execute handler
        Tool->>Tool: Chain.getLastBlock()
        Tool-->>Handler: {height: 12345, lastBlockHash: "0x..."}
        Handler->>Logger: Log: Tool executed successfully
        Handler->>Handler: Format result
        Handler-->>Server: Success response
        Server-->>Client: {content: [{type: "text", text: JSON}]}
    end
                </div>
                <div class="key-points">
                    <h3>Error Handling Features</h3>
                    <ul>
                        <li><strong>Tool Not Found</strong>: Check tools Map, throw error if null, log and return error response</li>
                        <li><strong>Validation Errors</strong>: Zod schema validation catches type errors, invalid values, missing required fields</li>
                        <li><strong>Handler Errors</strong>: Try-catch around handler execution, log error, format error message, throw</li>
                        <li><strong>Network/API Errors</strong>: Database errors, chain query failures, peer manager errors all caught and logged</li>
                        <li><strong>Error Messages</strong>: Descriptive error messages include tool name, error type, original error message</li>
                        <li><strong>Logging</strong>: All errors logged with [MCP] prefix for easy filtering and debugging</li>
                        <li><strong>Success Logging</strong>: Successful tool executions also logged for audit trail</li>
                    </ul>
                </div>
            </section>

            <!-- Diagram 10: Complete Lifecycle -->
            <section id="diagram-10" class="diagram-section">
                <h2>10. Complete MCP Lifecycle</h2>
                <p>
                    This comprehensive state machine shows the complete MCP lifecycle from server creation through tool registration,
                    server initialization, transport creation, request handling for all tool types, stop/restart, and graceful shutdown.
                </p>
                <div class="mermaid">
stateDiagram-v2
    [*] --> ServerCreation: Initialize MCP System

    ServerCreation --> CreateManager: new MCPServerManager(config)
    CreateManager --> ConfigureServer: Set name, version, description

    ConfigureServer --> ToolRegistration: Register tools

    state ToolRegistration {
        [*] --> CreateNetworkTools: createDemosNetworkTools()
        CreateNetworkTools --> EnableNetwork: enableNetworkTools?
        CreateNetworkTools --> EnableBlockchain: enableBlockchainTools?
        CreateNetworkTools --> EnablePeer: enablePeerTools?

        EnableNetwork --> RegisterNetworkTools: Register network tools
        EnableBlockchain --> RegisterBlockchainTools: Register blockchain tools
        EnablePeer --> RegisterPeerTools: Register peer tools

        RegisterNetworkTools --> ToolMap
        RegisterBlockchainTools --> ToolMap
        RegisterPeerTools --> ToolMap

        ToolMap --> [*]: Tools registered
    }

    ToolRegistration --> StartServer: start() called

    state StartServer {
        [*] --> CheckInitialized: Server initialized?
        CheckInitialized --> InitializeNow: No
        CheckInitialized --> CreateTransport: Yes

        InitializeNow --> CreateMCPServer: new Server(name, version)
        CreateMCPServer --> SetupHandlers: setupServerHandlers()
        SetupHandlers --> ListHandler: setRequestHandler(ListToolsRequestSchema)
        SetupHandlers --> CallHandler: setRequestHandler(CallToolRequestSchema)
        ListHandler --> CreateTransport
        CallHandler --> CreateTransport

        CreateTransport --> TransportType: Check transport type
        TransportType --> StartStdio: stdio
        TransportType --> StartSSE: sse

        StartStdio --> ConnectStdio: new StdioServerTransport()
        ConnectStdio --> StdioReady: server.connect(transport)

        StartSSE --> CreateExpress: Create Express app
        CreateExpress --> SetupCORS: Add CORS middleware
        SetupCORS --> CreateHTTP: Create HTTP server
        CreateHTTP --> SetupEndpoints: Setup /sse and /message
        SetupEndpoints --> ListenHTTP: server.listen(port, host)
        ListenHTTP --> SSEReady: SSE server listening

        StdioReady --> SetRunning
        SSEReady --> SetRunning
        SetRunning --> [*]: isRunning = true
    }

    StartServer --> ServerRunning: Server started

    state ServerRunning {
        [*] --> WaitForClient: Waiting for connections
        WaitForClient --> ClientConnects: Client connects
        ClientConnects --> HandleRequest: Receive request

        HandleRequest --> RequestType: Determine type
        RequestType --> HandleList: ListToolsRequest
        RequestType --> HandleCall: CallToolRequest

        HandleList --> BuildToolList: Iterate tools Map
        BuildToolList --> ReturnTools: Return {tools: Tool[]}
        ReturnTools --> WaitForClient

        HandleCall --> LookupTool: tools.get(name)
        LookupTool --> ToolFound: Tool exists?
        ToolFound --> ValidateArgs: Validate with Zod schema
        ToolFound --> ErrorNotFound: Tool not found
        ValidateArgs --> ValidationOK: Valid?
        ValidationOK --> ExecuteTool: tool.handler(args)
        ValidationOK --> ErrorValidation: Invalid args

        ExecuteTool --> QueryDemos: Query Demos Network
        QueryDemos --> GetSharedState: getSharedState
        QueryDemos --> QueryChain: Chain.getLastBlock/getBlockByNumber
        QueryDemos --> QueryPeers: PeerManager.getPeers

        GetSharedState --> ReturnData
        QueryChain --> ReturnData
        QueryPeers --> ReturnData

        ReturnData --> FormatResult: Format as {content: [...]}
        FormatResult --> LogSuccess: Log success
        LogSuccess --> WaitForClient

        ErrorNotFound --> LogError
        ErrorValidation --> LogError
        LogError --> ReturnError
        ReturnError --> WaitForClient
    }

    ServerRunning --> StopRequested: stop() called

    state StopRequested {
        [*] --> CheckRunning: Server running?
        CheckRunning --> NotRunning: No
        NotRunning --> [*]: Log warning

        CheckRunning --> CloseServer: Yes
        CloseServer --> ServerClose: server.close()
        ServerClose --> TransportClose: transport.close()
        TransportClose --> CheckHTTP: HTTP server exists?
        CheckHTTP --> CloseHTTP: Yes, close
        CheckHTTP --> ClearState: No HTTP server
        CloseHTTP --> ClearState: httpServer.close()
        ClearState --> SetNotRunning: isRunning = false
        SetNotRunning --> [*]: Server stopped
    }

    StopRequested --> ServerStopped: Server stopped

    ServerStopped --> Restart: start() called again
    Restart --> StartServer: Restart server

    ServerStopped --> Shutdown: shutdown() called

    state Shutdown {
        [*] --> StopIfRunning: Check if running
        StopIfRunning --> StopServer: Stop server
        StopServer --> ClearTools: tools.clear()
        ClearTools --> LogShutdown: Log shutdown complete
        LogShutdown --> [*]
    }

    Shutdown --> [*]: Graceful shutdown complete

    note right of ServerCreation
        Initialize MCPServerManager
        with config (name, version, transport)
    end note

    note right of ToolRegistration
        Tools registered before start
        Cannot register while running
    end note

    note right of ServerRunning
        Handle ListTools and CallTool
        Execute handlers with Demos APIs
    end note

    note right of Shutdown
        Graceful cleanup
        Close all connections
        Clear tools Map
    end note
                </div>
                <div class="key-points">
                    <h3>Complete Lifecycle Overview</h3>
                    <ul>
                        <li><strong>Initialization</strong>: Create MCPServerManager → configure name/version → register tools</li>
                        <li><strong>Tool Registration</strong>: Create tools with createDemosNetworkTools, register to tools Map before start</li>
                        <li><strong>Server Start</strong>: Initialize MCP Server → setup handlers → create transport (stdio or SSE)</li>
                        <li><strong>SSE Setup</strong>: Create Express app → CORS → HTTP server → /sse and /message endpoints → listen</li>
                        <li><strong>Request Handling</strong>: Wait for client → ListTools or CallTool → validate → execute → format → return</li>
                        <li><strong>Tool Execution</strong>: Query Demos Network APIs (getSharedState, Chain, PeerManager) → format result</li>
                        <li><strong>Stop/Restart</strong>: Close server → close transport → close HTTP → clear state → can restart</li>
                        <li><strong>Shutdown</strong>: Stop if running → clear tools Map → log shutdown complete</li>
                    </ul>
                </div>
            </section>
        </div>

        <footer>
            <p><strong>MCP (Model Context Protocol)</strong> - Comprehensive Diagram Documentation</p>
            <p>10 Detailed Mermaid Diagrams Covering Server Management, Dual Transport, Tool System, and Demos Network Integration</p>
            <p>Files: MCPServer.ts | index.ts | demosTools.ts</p>
        </footer>
    </div>

    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            securityLevel: 'loose',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            },
            sequence: {
                useMaxWidth: true,
                wrap: true,
                width: 150
            },
            stateDiagram: {
                useMaxWidth: true
            },
            er: {
                useMaxWidth: true
            },
            class: {
                useMaxWidth: true
            }
        });

        function showDiagram(num) {
            // Hide all sections
            const sections = document.querySelectorAll('.diagram-section');
            sections.forEach(section => {
                section.classList.remove('active');
            });

            // Remove active class from all buttons
            const buttons = document.querySelectorAll('.nav-btn');
            buttons.forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected section
            document.getElementById('diagram-' + num).classList.add('active');

            // Add active class to clicked button
            event.target.classList.add('active');

            // Scroll to top of content
            document.querySelector('.content').scrollIntoView({ behavior: 'smooth' });
        }
    </script>
</body>
</html>
