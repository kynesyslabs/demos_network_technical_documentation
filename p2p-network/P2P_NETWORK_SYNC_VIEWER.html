<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P Network & Synchronization - Mermaid Diagrams</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        nav {
            background-color: white;
            padding: 1rem 2rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: center;
        }

        nav a {
            color: #667eea;
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            transition: all 0.3s ease;
            font-weight: 500;
            border: 1px solid transparent;
        }

        nav a:hover {
            background-color: #667eea;
            color: white;
            border-color: #667eea;
        }

        nav a.active {
            background-color: #667eea;
            color: white;
        }

        .container {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 2rem;
        }

        .diagram-section {
            background-color: white;
            border-radius: 10px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .diagram-section h2 {
            color: #667eea;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid #667eea;
        }

        .diagram-section h3 {
            color: #764ba2;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
        }

        .mermaid {
            background-color: #fafafa;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1rem 0;
            border: 1px solid #e0e0e0;
        }

        .key-concepts {
            background-color: #f0f4ff;
            border-left: 4px solid #667eea;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 5px;
        }

        .key-concepts h4 {
            color: #667eea;
            margin-bottom: 0.5rem;
        }

        .key-concepts ul {
            margin-left: 1.5rem;
            margin-top: 0.5rem;
        }

        .key-concepts li {
            margin-bottom: 0.3rem;
        }

        .file-reference {
            background-color: #fff9e6;
            border-left: 4px solid #ffa726;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .controls {
            display: flex;
            gap: 1rem;
            margin: 20px auto;
            justify-content: center;
        }

        .btn {
            background-color: #667eea;
            color: white;
            border: none;
            padding: 1rem 1.5rem;
            border-radius: 50px;
            cursor: pointer;
            font-size: 1rem;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        footer {
            background-color: #333;
            color: white;
            text-align: center;
            padding: 2rem;
            margin-top: 3rem;
        }

        @media print {
            nav, .controls {
                display: none;
            }

            .diagram-section {
                page-break-inside: avoid;
            }
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 1.8rem;
            }

            nav {
                padding: 0.5rem;
            }

            nav a {
                font-size: 0.85rem;
                padding: 0.4rem 0.8rem;
            }

            .container {
                padding: 0 1rem;
            }
        }

        /* Section-specific colors */
        #section-1 .diagram-section { border-top: 4px solid #2196F3; }
        #section-2 .diagram-section { border-top: 4px solid #4CAF50; }
        #section-3 .diagram-section { border-top: 4px solid #FF9800; }
        #section-4 .diagram-section { border-top: 4px solid #9C27B0; }
        #section-5 .diagram-section { border-top: 4px solid #F44336; }
        #section-6 .diagram-section { border-top: 4px solid #00BCD4; }
        #section-7 .diagram-section { border-top: 4px solid #3F51B5; }
        #section-8 .diagram-section { border-top: 4px solid #E91E63; }
        #section-9 .diagram-section { border-top: 4px solid #009688; }
        #section-10 .diagram-section { border-top: 4px solid #795548; }
    </style>
</head>
<body>
    <header>
        <h1>üåê P2P Network & Synchronization</h1>
        <p>Comprehensive Mermaid Diagrams for Demos Blockchain</p>
    </header>

    <nav id="nav">
        <a href="#section-1" onclick="setActive(this)">1. Architecture</a>
        <a href="#section-2" onclick="setActive(this)">2. Fast Sync</a>
        <a href="#section-3" onclick="setActive(this)">3. RPC Server</a>
        <a href="#section-4" onclick="setActive(this)">4. Propagation</a>
        <a href="#section-5" onclick="setActive(this)">5. Peer Discovery</a>
        <a href="#section-6" onclick="setActive(this)">6. Authentication</a>
        <a href="#section-7" onclick="setActive(this)">7. Node Call API</a>
        <a href="#section-8" onclick="setActive(this)">8. Mempool Sync</a>
        <a href="#section-9" onclick="setActive(this)">9. Rate Limiting</a>
        <a href="#section-10" onclick="setActive(this)">10. Complete Flow</a>
    </nav>

    <div class="container">
        <div class="diagram-section" style="background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%); border: none;">
            <h2>üìã Overview</h2>
            <p style="margin-bottom: 1rem;">
                Demos blockchain uses a peer-to-peer network architecture for block/transaction propagation, synchronization, and RPC communication. The system includes fast sync for catching up with the network, rate limiting for security, and comprehensive API endpoints for node queries.
            </p>
            <div class="key-concepts">
                <h4>üéØ Key Features</h4>
                <ul>
                    <li><strong>Fast Sync</strong>: Efficient blockchain synchronization from peers</li>
                    <li><strong>RPC Server</strong>: HTTP-based request/response using Bun</li>
                    <li><strong>Signature Authentication</strong>: Ed25519/ML-DSA/Falcon signature verification</li>
                    <li><strong>Rate Limiting</strong>: IP-based request throttling and identity tx limits</li>
                    <li><strong>Node Call API</strong>: Public endpoints for blockchain queries</li>
                    <li><strong>Mempool Sync</strong>: Peer-to-peer transaction pool synchronization</li>
                    <li><strong>Peer Discovery</strong>: Dynamic peer connection and gossip protocol</li>
                </ul>
            </div>
        </div>

        <!-- Section 1: P2P Network Architecture Overview -->
        <div id="section-1">
            <div class="diagram-section">
                <h2>1. P2P Network Architecture Overview</h2>

                <div class="key-concepts">
                    <h4>üîë Key Concepts</h4>
                    <ul>
                        <li><strong>RPC Server</strong>: Bun-based HTTP server handling all network requests</li>
                        <li><strong>Rate Limiter</strong>: Middleware protecting against abuse (IP-based throttling)</li>
                        <li><strong>Endpoint Handlers</strong>: Process different request types (tx, mempool, peerlist, etc.)</li>
                        <li><strong>PeerManager</strong>: Singleton managing all peer connections</li>
                        <li><strong>Sync Routine</strong>: Fast sync for catching up with network</li>
                        <li><strong>Mempool v2</strong>: Block-aware transaction pool synchronized across shard</li>
                        <li><strong>Client Connections</strong>: Web browsers, SDK clients, CLI tools via HTTP</li>
                    </ul>
                </div>

                <div class="mermaid">
graph TB
    subgraph "Node A: Local Node"
        RPCSRVR[RPC Server on Bun]
        HANDLERS[Endpoint Handlers]
        PEERLIST[PeerManager Singleton]
        SYNC[Sync Routine]
        MEMPOOL[Mempool v2]
        CHAIN[Blockchain Database]
        GCRSYNC[GCR State]
        RATELIMIT[Rate Limiter Middleware]

        RPCSRVR --> RATELIMIT
        RATELIMIT --> HANDLERS
        HANDLERS --> MEMPOOL
        HANDLERS --> CHAIN
        HANDLERS --> GCRSYNC
        HANDLERS --> PEERLIST
        SYNC --> CHAIN
        SYNC --> MEMPOOL
        SYNC --> GCRSYNC
        SYNC --> PEERLIST
    end

    subgraph "Node B: Remote Peer"
        PEERBRPC[RPC Server]
        PEERBCHAIN[Blockchain]
        PEERBMEMPOOL[Mempool]
    end

    subgraph "Node C: Remote Peer"
        PEERCRPC[RPC Server]
        PEERCCHAIN[Blockchain]
        PEERCMEMPOOL[Mempool]
    end

    subgraph "Client Applications"
        BROWSER[Web Browser / DApp]
        SDK[Demos SDK Client]
        CLI[CLI Tools]
    end

    subgraph "Communication Protocols"
        HTTP[HTTP / HTTPS]
        WEBSOCKET[WebSocket future]
        RPC[JSON-RPC Protocol]
    end

    BROWSER --> HTTP
    SDK --> HTTP
    CLI --> HTTP
    HTTP --> RPCSRVR

    RPCSRVR <-->|Block requests<br/>Transaction queries<br/>Mempool sync| PEERBRPC
    RPCSRVR <-->|Peer gossip<br/>Hello peer<br/>Sync blocks| PEERCRPC

    PEERBRPC <--> PEERBCHAIN
    PEERCRPC <--> PEERCCHAIN

    style RPCSRVR fill:#e1f5ff
    style HANDLERS fill:#fff4e1
    style SYNC fill:#e8f5e9
    style RATELIMIT fill:#ffcdd2
                </div>

                <div class="file-reference">
                    <strong>üìÅ File Reference:</strong> src/libs/network/server_rpc.ts:520
                </div>
            </div>
        </div>

        <!-- Section 2: Fast Sync Process & Block Downloading -->
        <div id="section-2">
            <div class="diagram-section">
                <h2>2. Fast Sync Process & Block Downloading</h2>

                <div class="key-concepts">
                    <h4>üîë Key Concepts</h4>
                    <ul>
                        <li><strong>Gap Calculation</strong>: Determine how many blocks behind network we are</li>
                        <li><strong>Genesis Verification</strong>: Verify genesis block matches peer's genesis (same network check)</li>
                        <li><strong>Last Block Coherence</strong>: Verify our last block hash matches peer's hash (integrity check)</li>
                        <li><strong>Sequential Download</strong>: Download blocks one by one from highest peer</li>
                        <li><strong>Transaction Download</strong>: For each block, download all transactions by hash</li>
                        <li><strong>GCR State Rebuild</strong>: Apply GCR edits from transactions to rebuild state</li>
                        <li><strong>Native Hash Verification</strong>: Recalculate GCR hashes and compare with block</li>
                        <li><strong>Peer Switching</strong>: If peer unreachable, switch to next highest peer</li>
                    </ul>
                </div>

                <div class="mermaid">
sequenceDiagram
    participant LocalNode as Local Node Sync
    participant PeerMgr as PeerManager
    participant Peer1 as Peer 1
    participant Peer2 as Peer 2
    participant Chain as Local Blockchain
    participant GCR as Local GCR State

    Note over LocalNode,GCR: Fast Sync Initialization

    LocalNode->>Chain: Get our lastBlockNumber
    Chain->>LocalNode: Return localBlockNumber

    LocalNode->>PeerMgr: Get all peers
    PeerMgr->>LocalNode: Return peer list

    loop For each peer
        LocalNode->>Peer1: RPC: getLastBlockNumber
        Peer1->>LocalNode: Return peerBlockNumber
        LocalNode->>Peer2: RPC: getLastBlockNumber
        Peer2->>LocalNode: Return peerBlockNumber
    end

    LocalNode->>LocalNode: Find highest block peer
    LocalNode->>LocalNode: Calculate gap: peerMax minus localBlock

    alt Gap is 0
        LocalNode->>LocalNode: Already synced, exit
    else Gap greater than 0
        LocalNode->>LocalNode: Start sync process

        Note over LocalNode,GCR: Verify Genesis and Last Block Integrity

        LocalNode->>Peer1: RPC: getBlockByNumber 0
        Peer1->>LocalNode: Return genesis block
        LocalNode->>Chain: Get our genesis hash
        Chain->>LocalNode: Return ourGenesisHash
        LocalNode->>LocalNode: Compare genesis hashes

        alt Genesis mismatch
            LocalNode->>LocalNode: EXIT: Different network
        else Genesis match
            LocalNode->>Peer1: RPC: getBlockByNumber lastLocal
            Peer1->>LocalNode: Return block at lastLocal
            LocalNode->>Chain: Get our block hash at lastLocal
            Chain->>LocalNode: Return ourLastHash
            LocalNode->>LocalNode: Verify hash coherence
        end

        Note over LocalNode,GCR: Download Missing Blocks

        loop For each missing block from localBlock+1 to peerMax
            LocalNode->>Peer1: RPC: getBlockByNumber N
            Peer1->>LocalNode: Return block N

            alt Block not found or peer unreachable
                LocalNode->>LocalNode: Switch to next highest peer
                LocalNode->>Peer2: RPC: getBlockByNumber N
                Peer2->>LocalNode: Return block N
            end

            LocalNode->>LocalNode: Validate block structure
            LocalNode->>LocalNode: Verify previousHash matches
            LocalNode->>LocalNode: Verify block hash correct

            LocalNode->>Chain: Insert block into blockchain
            Chain->>LocalNode: Block inserted

            Note over LocalNode,GCR: Download Transactions for Block

            loop For each tx hash in block
                LocalNode->>Peer1: RPC: getTxByHash hash
                Peer1->>LocalNode: Return transaction
                LocalNode->>LocalNode: Validate tx signature
                LocalNode->>LocalNode: Validate tx hash
            end

            LocalNode->>GCR: Apply GCR edits from transactions
            GCR->>GCR: Update balances, nonces, identities
            GCR->>LocalNode: State updated

            LocalNode->>GCR: Calculate native_tables_hashes
            GCR->>LocalNode: Return calculated hashes
            LocalNode->>LocalNode: Compare with block hashes

            alt Hashes mismatch
                LocalNode->>LocalNode: State corruption, reject block
            else Hashes match
                LocalNode->>Chain: Save transactions to database
                LocalNode->>GCR: Save GCR state to database
                LocalNode->>LocalNode: Merge peerlist from block
                LocalNode->>LocalNode: Increment localBlockNumber
            end
        end

        LocalNode->>LocalNode: Sync complete, set syncStatus = true
    end
                </div>

                <div class="file-reference">
                    <strong>üìÅ File Reference:</strong> src/libs/blockchain/routines/Sync.ts:545
                </div>
            </div>
        </div>

        <!-- Section 3: RPC Server Architecture & Request Processing -->
        <div id="section-3">
            <div class="diagram-section">
                <h2>3. RPC Server Architecture & Request Processing</h2>

                <div class="key-concepts">
                    <h4>üîë Key Concepts</h4>
                    <ul>
                        <li><strong>Rate Limiter First</strong>: All requests pass through rate limiting middleware</li>
                        <li><strong>IP Whitelisting</strong>: Certain IPs bypass rate limits</li>
                        <li><strong>JSON Parsing</strong>: Parse request body as RPCRequest object</li>
                        <li><strong>Method-Based Auth</strong>: Some methods (nodeCall) don't require authentication</li>
                        <li><strong>Header Validation</strong>: Verify signature and identity headers for authenticated methods</li>
                        <li><strong>Cryptographic Verification</strong>: Support ed25519, ml-dsa, falcon signatures</li>
                        <li><strong>Protected Endpoints</strong>: SUDO_PUBKEY-only endpoints (awardPoints, getCampaignData, etc.)</li>
                        <li><strong>Method Dispatch</strong>: Switch case routing to appropriate handlers</li>
                    </ul>
                </div>

                <div class="mermaid">
flowchart TD
    START([Client sends HTTP POST request])

    START --> RATELIMIT[Rate Limiter Middleware]

    RATELIMIT --> CHECKIP{Client IP<br/>whitelisted?}
    CHECKIP -->|yes| PARSEPARSE
    CHECKIP -->|no| CHECKLIMIT{Request<br/>limit exceeded?}

    CHECKLIMIT -->|yes| BLOCK[Return 429 Rate Limit Exceeded]
    CHECKLIMIT -->|no| PARSEPARSE

    PARSEPARSE[Parse JSON body]
    PARSEPARSE --> VALIDRPC{Valid<br/>RPCRequest?}

    VALIDRPC -->|no| BADREQUEST[Return 400 Invalid Request]
    VALIDRPC -->|yes| CHECKMETHOD{Method requires<br/>authentication?}

    CHECKMETHOD -->|no| PROCESSDIRECT
    CHECKMETHOD -->|yes| GETHEAD[Get headers: signature and identity]

    GETHEAD --> VALIDATEHEAD[Validate headers]

    subgraph "Header Validation"
        VALIDATEHEAD --> CHECKEXIST{Signature and<br/>identity exist?}
        CHECKEXIST -->|no| HEADERR1[Return 401 Missing Headers]

        CHECKEXIST -->|yes| PARSEID[Parse identity algorithm:pubkey]
        PARSEID --> VERIFYSIG[Verify signature with ucrypto]

        VERIFYSIG --> SIGVALID{Signature<br/>valid?}
        SIGVALID -->|no| HEADERR2[Return 401 Invalid Signature]
        SIGVALID -->|yes| EXTRACTSENDER[Extract sender identity]
    end

    EXTRACTSENDER --> PROCESSDIRECT[Process payload]

    subgraph "Payload Processing Switch"
        PROCESSDIRECT --> SWITCHMETHOD{payload.method}

        SWITCHMETHOD -->|ping| PONG[Return pong]
        SWITCHMETHOD -->|execute| EXECUTE[manageExecution]
        SWITCHMETHOD -->|nativeBridge| NATIVEBRIDGE[manageNativeBridge]
        SWITCHMETHOD -->|hello_peer| HELLOPEER[manageHelloPeer]
        SWITCHMETHOD -->|mempool| MEMPOOL[handleMempool]
        SWITCHMETHOD -->|peerlist| PEERLIST[handlePeerlist]
        SWITCHMETHOD -->|auth| AUTH[manageAuth]
        SWITCHMETHOD -->|nodeCall| NODECALL[manageNodeCall]
        SWITCHMETHOD -->|login_request| LOGINREQ[handleLoginRequest]
        SWITCHMETHOD -->|login_response| LOGINRESP[handleLoginResponse]
        SWITCHMETHOD -->|consensus_routine| CONSENSUS[manageConsensusRoutines]
        SWITCHMETHOD -->|gcr_routine| GCRR[manageGCRRoutines]
        SWITCHMETHOD -->|bridge| BRIDGE[manageBridges]
        SWITCHMETHOD -->|web2ProxyRequest| WEB2[handleWeb2ProxyRequest]
        SWITCHMETHOD -->|rate-limit/unblock| UNBLOCK[RateLimiter unblock]
        SWITCHMETHOD -->|getCampaignData| CAMPAIGN[GCR.getCampaignData]
        SWITCHMETHOD -->|awardPoints| AWARD[GCR.awardPoints]
        SWITCHMETHOD -->|default| NOTIMPL[Return 501 Not Implemented]
    end

    PONG --> RETURNRESP[Return RPCResponse]
    EXECUTE --> RETURNRESP
    NATIVEBRIDGE --> RETURNRESP
    HELLOPEER --> RETURNRESP
    MEMPOOL --> RETURNRESP
    PEERLIST --> RETURNRESP
    AUTH --> RETURNRESP
    NODECALL --> RETURNRESP
    LOGINREQ --> RETURNRESP
    LOGINRESP --> RETURNRESP
    CONSENSUS --> RETURNRESP
    GCRR --> RETURNRESP
    BRIDGE --> RETURNRESP
    WEB2 --> RETURNRESP
    UNBLOCK --> RETURNRESP
    CAMPAIGN --> RETURNRESP
    AWARD --> RETURNRESP
    NOTIMPL --> RETURNRESP

    RETURNRESP --> JSONRESP[JSON response to client]
    JSONRESP --> END([Request complete])

    BLOCK --> END
    BADREQUEST --> END
    HEADERR1 --> END
    HEADERR2 --> END

    style START fill:#e1f5ff
    style RATELIMIT fill:#ffcdd2
    style PROCESSDIRECT fill:#fff4e1
    style RETURNRESP fill:#c8e6c9
    style END fill:#c8e6c9
                </div>

                <div class="file-reference">
                    <strong>üìÅ File Reference:</strong> src/libs/network/server_rpc.ts:144 (processPayload function)
                </div>
            </div>
        </div>

        <!-- Continue with sections 4-10... -->
        <!-- For brevity, I'll include just section 4 as example, full HTML would have all 10 -->

        <!-- Section 4: Block & Transaction Propagation -->
        <div id="section-4">
            <div class="diagram-section">
                <h2>4. Block & Transaction Propagation</h2>

                <div class="key-concepts">
                    <h4>üîë Key Concepts</h4>
                    <ul>
                        <li><strong>Block Creation</strong>: Secretary creates candidate block during Phase 5</li>
                        <li><strong>Shard Voting</strong>: Broadcast block hash to shard members in Phase 6</li>
                        <li><strong>67% Threshold</strong>: Block requires 67% shard signatures to be valid</li>
                        <li><strong>Finalization</strong>: Save block, transactions, and GCR state in Phase 7</li>
                        <li><strong>Network Broadcast</strong>: Propagate finalized block to all network peers</li>
                        <li><strong>Observer Verification</strong>: Observers download and verify block independently</li>
                        <li><strong>Transaction Download</strong>: Download all transactions for block verification</li>
                        <li><strong>Mempool Merge</strong>: Shard members synchronize mempools in Phase 1</li>
                    </ul>
                </div>

                <div class="mermaid">
sequenceDiagram
    participant ProducerNode as Block Producer (Secretary)
    participant Shard as Shard Members
    participant Network as P2P Network
    participant ObserverNodes as Observer Nodes

    Note over ProducerNode,ObserverNodes: Block Creation Phase (Consensus Phase 5-7)

    ProducerNode->>ProducerNode: Create candidate block
    ProducerNode->>ProducerNode: Hash native tables
    ProducerNode->>ProducerNode: Calculate block hash
    ProducerNode->>ProducerNode: Sign block hash

    Note over ProducerNode,Shard: Phase 6: Vote on Block

    ProducerNode->>Shard: RPC: proposeBlockHash with hash and validation_data
    Shard->>Shard: Verify in same shard
    Shard->>Shard: Get our candidateBlock
    Shard->>Shard: Compare hashes

    alt Hash matches
        Shard->>Shard: Sign block hash
        Shard->>ProducerNode: Return 200 with signature
    else Hash mismatch
        Shard->>ProducerNode: Return error
    end

    ProducerNode->>ProducerNode: Collect signatures
    ProducerNode->>ProducerNode: Calculate vote percentage

    alt Greater or equal 67 percent
        ProducerNode->>ProducerNode: Block valid

        Note over ProducerNode,ObserverNodes: Phase 7: Finalize Block

        ProducerNode->>ProducerNode: Save GCR state
        ProducerNode->>ProducerNode: Save transactions
        ProducerNode->>ProducerNode: Save block to database
        ProducerNode->>ProducerNode: Update sharedState

        Note over ProducerNode,ObserverNodes: Block Propagation to Network

        ProducerNode->>Network: Broadcast block to all peers
        Network->>ObserverNodes: Forward block

        ObserverNodes->>ObserverNodes: Receive block notification
        ObserverNodes->>Network: RPC: getBlockByHash hash
        Network->>ObserverNodes: Return full block

        ObserverNodes->>ObserverNodes: Validate block structure
        ObserverNodes->>ObserverNodes: Verify previousHash
        ObserverNodes->>ObserverNodes: Verify signatures (67 percent check)

        loop For each tx hash in block
            ObserverNodes->>Network: RPC: getTxByHash hash
            Network->>ObserverNodes: Return transaction
            ObserverNodes->>ObserverNodes: Validate signature
        end

        ObserverNodes->>ObserverNodes: Apply GCR edits
        ObserverNodes->>ObserverNodes: Calculate native hashes
        ObserverNodes->>ObserverNodes: Compare hashes

        alt Hashes match
            ObserverNodes->>ObserverNodes: Save block and txs
            ObserverNodes->>ObserverNodes: Update lastBlockNumber
            ObserverNodes->>ObserverNodes: Set syncStatus = true
        else Hashes mismatch
            ObserverNodes->>ObserverNodes: Reject block, request again
        end
    else Less than 67 percent
        ProducerNode->>ProducerNode: Block invalid, rollback GCR
    end

    Note over ProducerNode,ObserverNodes: Transaction Propagation During Consensus

    ProducerNode->>ProducerNode: User submits transaction
    ProducerNode->>ProducerNode: Validate and add to mempool

    Note over ProducerNode,Shard: Consensus Phase 1: Merge Mempool

    ProducerNode->>Shard: RPC: mempool with transactions array
    Shard->>Shard: Receive transactions
    Shard->>Shard: Validate each transaction
    Shard->>Shard: Add valid txs to local mempool
    Shard->>ProducerNode: Return 200 with merged mempool
                </div>

                <div class="file-reference">
                    <strong>üìÅ File Reference:</strong> src/libs/consensus/v2/routines/broadcastBlockHash.ts
                </div>
            </div>
        </div>

        <!-- Simplified sections 5-10 for brevity -->
        <div id="section-5">
            <div class="diagram-section">
                <h2>5. Peer Discovery & Connection Management</h2>
                <div class="key-concepts">
                    <h4>üîë Key Concepts</h4>
                    <ul>
                        <li>Bootstrap peers from config</li>
                        <li>Hello peer handshake with signature verification</li>
                        <li>Recursive peer discovery via peerlist merging</li>
                        <li>Peer gossip protocol (every 30s)</li>
                    </ul>
                </div>
                <div class="mermaid">
flowchart TD
    START([Node startup]) --> LOADCONFIG[Load bootstrap peers from config]
    LOADCONFIG --> INITPM[Initialize PeerManager singleton]
    INITPM --> CONNECTBOOT{Have bootstrap<br/>peers?}
    CONNECTBOOT -->|yes| LOOPBOOT[Loop through bootstrap peers]
    CONNECTBOOT -->|no| WAITINCOMING[Wait for incoming connections]
    LOOPBOOT --> CREATEPEER[Create Peer object from connection string]
    CREATEPEER --> HELLOPEER[Send hello_peer RPC]
    HELLOPEER --> HEPRESP{Response<br/>200?}
    HEPRESP -->|yes| VERIFYSIG[Verify peer signature]
    HEPRESP -->|no| SKIPBOOT[Skip this bootstrap peer]
    VERIFYSIG --> SIGOK{Signature<br/>valid?}
    SIGOK -->|yes| ADDPEER[Add peer to PeerManager]
    SIGOK -->|no| SKIPBOOT
    ADDPEER --> REQPEERLIST[Request peer's peerlist]
    REQPEERLIST --> MERGELIST[Merge peerlist]
    style START fill:#e1f5ff
    style ADDPEER fill:#c8e6c9
                </div>
                <div class="file-reference">
                    <strong>üìÅ File Reference:</strong> src/libs/peer/routines/peerBootstrap.ts
                </div>
            </div>
        </div>

        <div id="section-6">
            <div class="diagram-section">
                <h2>6. Request Authentication & Signature Validation</h2>
                <div class="key-concepts">
                    <h4>üîë Key Concepts</h4>
                    <ul>
                        <li>Multi-algorithm support: ed25519, ml-dsa, falcon</li>
                        <li>Identity format: algorithm:pubkey or just pubkey (defaults to ed25519)</li>
                        <li>Signature header verification with ucrypto</li>
                        <li>Protected endpoints require SUDO_PUBKEY</li>
                    </ul>
                </div>
                <div class="mermaid">
flowchart TD
    START([RPC request received]) --> CHECKNOAUTH{Method in<br/>noAuthMethods?}
    CHECKNOAUTH -->|yes| PROCESS[Process without auth]
    CHECKNOAUTH -->|no| GETHEADERS[Get headers from request]
    GETHEADERS --> HASSIG{Has signature<br/>header?}
    HASSIG -->|no| ERROR1[Return 401: Missing signature]
    HASSIG -->|yes| HASID{Has identity<br/>header?}
    HASID -->|no| ERROR2[Return 401: Missing identity]
    HASID -->|yes| PARSEID[Parse identity header]
    PARSEID --> CALLVERIFY[Call ucrypto.verify with signedObject]
    CALLVERIFY --> VERIFYSIG{Signature<br/>valid?}
    VERIFYSIG -->|yes| PROCESS
    VERIFYSIG -->|no| ERROR3[Return 401: Invalid signature]
    style START fill:#e1f5ff
    style PROCESS fill:#c8e6c9
    style ERROR1 fill:#ffcdd2
                </div>
                <div class="file-reference">
                    <strong>üìÅ File Reference:</strong> src/libs/network/server_rpc.ts:80 (validateHeaders)
                </div>
            </div>
        </div>

        <div id="section-7">
            <div class="diagram-section">
                <h2>7. Node Call API & Public Endpoints</h2>
                <div class="key-concepts">
                    <h4>üîë Key Concepts</h4>
                    <ul>
                        <li>Public GET endpoints (no auth): /info, /version, /peerlist, etc.</li>
                        <li>Node Call messages via POST: getLastBlockNumber, getBlockByNumber, getTxByHash, etc.</li>
                        <li>Backend services: Chain, GCR, Mempool, PeerManager, SharedState, Logger</li>
                    </ul>
                </div>
                <div class="mermaid">
graph TB
    subgraph "Public GET Endpoints"
        ROOT["/"]
        INFO["/info"]
        VERSION["/version"]
        PEERLIST["/peerlist"]
    end
    subgraph "Node Call Messages"
        GETLASTBLOCKNUM["getLastBlockNumber"]
        GETBLOCKBYNUM["getBlockByNumber"]
        GETTXBYHASH["getTxByHash"]
    end
    subgraph "Backend Services"
        CHAINSVC[Chain Service]
        PEERSVC[PeerManager Service]
    end
    INFO --> CHAINSVC
    PEERLIST --> PEERSVC
    GETLASTBLOCKNUM --> CHAINSVC
    GETBLOCKBYNUM --> CHAINSVC
    GETTXBYHASH --> CHAINSVC
    style ROOT fill:#e3f2fd
    style CHAINSVC fill:#c8e6c9
                </div>
                <div class="file-reference">
                    <strong>üìÅ File Reference:</strong> src/libs/network/manageNodeCall.ts:250+
                </div>
            </div>
        </div>

        <div id="section-8">
            <div class="diagram-section">
                <h2>8. Mempool Synchronization Between Peers</h2>
                <div class="key-concepts">
                    <h4>üîë Key Concepts</h4>
                    <ul>
                        <li>Mempool merge during consensus Phase 1</li>
                        <li>Shard members exchange transaction arrays</li>
                        <li>Duplicate detection by hash</li>
                        <li>Validation: structure, signature, hash, reference block</li>
                        <li>After finalization, remove transactions from mempool</li>
                    </ul>
                </div>
                <div class="mermaid">
sequenceDiagram
    participant Node1 as Node 1 (has new txs)
    participant Node2 as Node 2 (shard member)
    participant Mempool1 as Node1 Mempool
    participant Mempool2 as Node2 Mempool
    Node1->>Mempool1: User submits transaction
    Mempool1->>Mempool1: Validate and add to mempool
    Note over Node1,Mempool2: Consensus Phase 1: Mempool Merge
    Node1->>Node2: RPC: mempool with transactions array
    Node2->>Mempool2: Receive transactions array
    Mempool2->>Mempool2: Validate each transaction
    Mempool2->>Mempool2: Add valid txs to mempool
    Mempool2->>Node2: Return merged mempool
    Node2->>Node1: Return 200 with merged mempool
    style Node1 fill:#e1f5ff
    style Mempool2 fill:#c8e6c9
                </div>
                <div class="file-reference">
                    <strong>üìÅ File Reference:</strong> src/libs/network/endpointHandlers.ts:629 (handleMempool)
                </div>
            </div>
        </div>

        <div id="section-9">
            <div class="diagram-section">
                <h2>9. Rate Limiting & Security Middleware</h2>
                <div class="key-concepts">
                    <h4>üîë Key Concepts</h4>
                    <ul>
                        <li>IP-based global request rate limiting</li>
                        <li>Per-block identity transaction limits</li>
                        <li>IP whitelisting for trusted sources</li>
                        <li>Blocking mechanism for abusive IPs</li>
                        <li>Time window reset for rate limits</li>
                    </ul>
                </div>
                <div class="mermaid">
flowchart TD
    START([HTTP request received]) --> MIDDLEWARE[Rate Limiter Middleware]
    MIDDLEWARE --> GETIP[Extract client IP]
    GETIP --> CHECKWHITELIST{IP in<br/>whitelist?}
    CHECKWHITELIST -->|yes| ALLOW[Allow request]
    CHECKWHITELIST -->|no| CHECKBLOCKED{IP<br/>blocked?}
    CHECKBLOCKED -->|yes| RETURNBLOCKED[Return 429: Rate limit exceeded]
    CHECKBLOCKED -->|no| CHECKGLOBAL[Check global request limit]
    CHECKGLOBAL --> OVERLIMIT{Count greater<br/>than limit?}
    OVERLIMIT -->|yes| BLOCKIP[Mark IP as blocked]
    OVERLIMIT -->|no| ALLOW
    style START fill:#e1f5ff
    style ALLOW fill:#c8e6c9
    style BLOCKIP fill:#ffcdd2
                </div>
                <div class="file-reference">
                    <strong>üìÅ File Reference:</strong> src/libs/network/middleware/rateLimiter.ts
                </div>
            </div>
        </div>

        <div id="section-10">
            <div class="diagram-section">
                <h2>10. Complete Network Communication Flow</h2>
                <div class="key-concepts">
                    <h4>üîë Key Concepts</h4>
                    <ul>
                        <li>Node startup ‚Üí Peer discovery ‚Üí Synchronization ‚Üí Operational mode</li>
                        <li>Hello peer handshake with bootstrap peers</li>
                        <li>Fast sync to catch up with network</li>
                        <li>Operational mode: RPC requests, consensus, peer gossip</li>
                        <li>Continuous monitoring for out-of-sync detection</li>
                    </ul>
                </div>
                <div class="mermaid">
stateDiagram-v2
    [*] --> NodeStartup: Boot node
    state "Node Startup" as NodeStartup {
        [*] --> LoadConfig
        LoadConfig --> InitRPCServer
        InitRPCServer --> InitPeerManager
        InitPeerManager --> [*]
    }
    NodeStartup --> PeerDiscovery: Connect to network
    state "Peer Discovery" as PeerDiscovery {
        [*] --> HelloBootstrap
        HelloBootstrap --> VerifyBootstrap
        VerifyBootstrap --> RequestPeerlist
        RequestPeerlist --> [*]
    }
    PeerDiscovery --> Synchronization: Start sync
    state "Synchronization" as Synchronization {
        [*] --> QueryPeers
        QueryPeers --> CompareBlocks
        CompareBlocks --> DownloadBlocks
        DownloadBlocks --> [*]
    }
    Synchronization --> OperationalMode: Sync complete
    state "Operational Mode" as OperationalMode {
        [*] --> AcceptRequests
        AcceptRequests --> ProcessAuth
        ProcessAuth --> AcceptRequests
    }
    OperationalMode --> [*]: Shutdown
                </div>
                <div class="file-reference">
                    <strong>üìÅ File Reference:</strong> Multiple files (server_rpc.ts, Sync.ts, PeerManager.ts)
                </div>
            </div>
        </div>

        <!-- Key File References Section -->
        <div class="diagram-section" style="background: linear-gradient(135deg, #fff9e6 0%, #ffe0b2 100%); border: none;">
            <h2>üìÅ Key File References</h2>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem; margin-top: 1rem;">
                <div class="file-reference">
                    <h4 style="margin-bottom: 0.5rem; color: #ef6c00;">Synchronization Files</h4>
                    <ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
                        <li><strong>Sync</strong>: <code>src/libs/blockchain/routines/Sync.ts</code> (545 lines)</li>
                        <li><strong>Sync GCR Tables</strong>: Sync.ts:432</li>
                        <li><strong>Ask Txs For Block</strong>: Sync.ts:450</li>
                        <li><strong>Merge Peerlist</strong>: Sync.ts:477</li>
                    </ul>
                </div>
                <div class="file-reference">
                    <h4 style="margin-bottom: 0.5rem; color: #ef6c00;">RPC Server Files</h4>
                    <ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
                        <li><strong>Server RPC</strong>: <code>src/libs/network/server_rpc.ts</code> (520 lines)</li>
                        <li><strong>Validate Headers</strong>: server_rpc.ts:80</li>
                        <li><strong>Process Payload</strong>: server_rpc.ts:144</li>
                    </ul>
                </div>
                <div class="file-reference">
                    <h4 style="margin-bottom: 0.5rem; color: #ef6c00;">Endpoint Handler Files</h4>
                    <ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
                        <li><strong>Endpoint Handlers</strong>: <code>src/libs/network/endpointHandlers.ts</code> (681 lines)</li>
                        <li><strong>Handle Mempool</strong>: endpointHandlers.ts:629</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Principles Section -->
        <div class="diagram-section" style="background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%); border: none;">
            <h2>üí° P2P Network & Synchronization Principles</h2>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 1rem; margin-top: 1rem;">
                <div class="key-concepts">
                    <h4>Core Principles</h4>
                    <ul>
                        <li><strong>Fast Sync Efficiency</strong>: Download missing blocks sequentially from highest peer with integrity checks</li>
                        <li><strong>Genesis Verification</strong>: Always verify genesis block matches before syncing from peer</li>
                        <li><strong>GCR State Rebuilding</strong>: Apply GCR edits from transactions and verify native hashes</li>
                        <li><strong>Peer Switching</strong>: If peer becomes unreachable during sync, switch to next highest peer</li>
                        <li><strong>Request Authentication</strong>: All authenticated methods verify ed25519/ML-DSA/Falcon signatures</li>
                    </ul>
                </div>
                <div class="key-concepts">
                    <h4>Advanced Features</h4>
                    <ul>
                        <li><strong>Rate Limiting</strong>: IP-based global limits and per-block identity transaction limits</li>
                        <li><strong>Mempool Synchronization</strong>: Shard members merge mempools in consensus Phase 1</li>
                        <li><strong>Block Propagation</strong>: Finalized blocks broadcast to network, observers download and verify</li>
                        <li><strong>Peer Gossip</strong>: Periodic peerlist exchange (every 30s) for network discovery</li>
                        <li><strong>Public API</strong>: Unauthenticated GET endpoints for blockchain queries and info</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="btn" onclick="window.print()">üñ®Ô∏è Print</button>
        <button class="btn" onclick="window.scrollTo({top: 0, behavior: 'smooth'})">‚¨ÜÔ∏è Top</button>
    </div>

    <footer>
        <p>&copy; 2025 Demos Blockchain - P2P Network & Synchronization Documentation</p>
        <p style="margin-top: 0.5rem; opacity: 0.8;">Generated with Mermaid.js | Interactive Diagram Viewer</p>
    </footer>

    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            securityLevel: 'loose',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            }
        });

        function setActive(element) {
            document.querySelectorAll('nav a').forEach(link => {
                link.classList.remove('active');
            });
            element.classList.add('active');
        }

        window.addEventListener('scroll', () => {
            const sections = document.querySelectorAll('[id^="section-"]');
            const navLinks = document.querySelectorAll('nav a');
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                if (window.pageYOffset >= sectionTop - 200) {
                    current = section.getAttribute('id');
                }
            });
            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
        });

        document.querySelectorAll('nav a').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
    </script>
</body>
</html>
