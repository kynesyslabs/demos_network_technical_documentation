<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Peer & Validator Management - Interactive Diagrams</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            color: white;
            padding: 40px 20px;
            margin-bottom: 30px;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .key-features {
            background: white;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .key-features h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .key-features ul {
            list-style: none;
            padding-left: 0;
        }

        .key-features li {
            padding: 8px 0;
            padding-left: 30px;
            position: relative;
        }

        .key-features li:before {
            content: "‚úì";
            position: absolute;
            left: 0;
            color: #667eea;
            font-weight: bold;
            font-size: 1.2em;
        }

        nav {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        nav h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        nav ul {
            list-style: none;
        }

        nav li {
            margin: 8px 0;
        }

        nav a {
            color: #555;
            text-decoration: none;
            display: block;
            padding: 10px 15px;
            border-radius: 5px;
            transition: all 0.3s ease;
            border-left: 3px solid transparent;
        }

        nav a:hover {
            background: #f0f0f0;
            border-left-color: #667eea;
            transform: translateX(5px);
        }

        .diagram-section {
            background: white;
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .diagram-section h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .diagram-section.architecture h2 { border-bottom-color: #667eea; }
        .diagram-section.lifecycle h2 { border-bottom-color: #48bb78; }
        .diagram-section.handshake h2 { border-bottom-color: #ed8936; }
        .diagram-section.gossip h2 { border-bottom-color: #9f7aea; }
        .diagram-section.entrance h2 { border-bottom-color: #38b2ac; }
        .diagram-section.rpc h2 { border-bottom-color: #f56565; }
        .diagram-section.status h2 { border-bottom-color: #4299e1; }
        .diagram-section.sync h2 { border-bottom-color: #ed64a6; }
        .diagram-section.points h2 { border-bottom-color: #ecc94b; }
        .diagram-section.flow h2 { border-bottom-color: #fc8181; }

        .key-concepts {
            background: #f7fafc;
            border-left: 4px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .key-concepts h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .key-concepts ul {
            margin-left: 20px;
        }

        .key-concepts li {
            margin: 5px 0;
        }

        .mermaid {
            background: white;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }

        .file-references {
            background: #f7fafc;
            border-radius: 5px;
            padding: 20px;
            margin: 20px 0;
        }

        .file-references h3 {
            color: #667eea;
            margin-bottom: 15px;
        }

        .file-references code {
            background: #edf2f7;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #d6336c;
        }

        footer {
            text-align: center;
            color: white;
            padding: 30px;
            margin-top: 40px;
        }

        @media print {
            body {
                background: white;
            }
            nav {
                display: none;
            }
            .diagram-section {
                page-break-inside: avoid;
            }
        }

        .print-btn {
            display: inline-block;
            margin: 20px auto;
            background: #667eea;
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .print-btn:hover {
            background: #5568d3;
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üåê Peer & Validator Management</h1>
            <p>Interactive Mermaid Diagram Documentation</p>
        </header>

        <div class="key-features">
            <h2>Key Features of Peer & Validator System</h2>
            <ul>
                <li><strong>PeerManager Singleton</strong> for centralized peer management</li>
                <li><strong>Peer Gossip Protocol</strong> for decentralized peer list synchronization</li>
                <li><strong>Hello Peer Handshake</strong> with cryptographic verification</li>
                <li><strong>Sync Status Tracking</strong> for blockchain state synchronization</li>
                <li><strong>Online/Offline Detection</strong> with retry logic</li>
                <li><strong>Validator Selection</strong> based on sync status and stake</li>
                <li><strong>Point/Reputation System</strong> stored in GCR for incentives</li>
            </ul>
        </div>

        <nav>
            <h3>üìã Navigation</h3>
            <ul>
                <li><a href="#architecture">1. PeerManager Architecture Overview</a></li>
                <li><a href="#lifecycle">2. Peer Lifecycle & Bootstrap Process</a></li>
                <li><a href="#handshake">3. Hello Peer Handshake Protocol</a></li>
                <li><a href="#gossip">4. Peer Gossip Protocol</a></li>
                <li><a href="#entrance">5. Validator Entrance & Management</a></li>
                <li><a href="#rpc">6. Peer Connection & RPC System</a></li>
                <li><a href="#status">7. Online/Offline Status Management</a></li>
                <li><a href="#sync">8. Sync Status Tracking</a></li>
                <li><a href="#points">9. Point/Reputation System</a></li>
                <li><a href="#flow">10. Complete Peer-to-Validator Flow</a></li>
            </ul>
        </nav>

        <section id="architecture" class="diagram-section architecture">
            <h2>1. PeerManager Architecture Overview</h2>

            <div class="key-concepts">
                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Singleton Pattern</strong>: One PeerManager instance manages all peers</li>
                    <li><strong>peerList</strong>: Record of online, authenticated peers</li>
                    <li><strong>offlinePeers</strong>: Record of offline peers for retry</li>
                    <li><strong>Peer Structure</strong>: connection, identity, verification, sync, status</li>
                    <li><strong>demos_peer.json</strong>: Persistent peer list storage</li>
                    <li><strong>sayHelloToPeer</strong>: Cryptographic handshake with signature verification</li>
                </ul>
            </div>

            <div class="mermaid">
graph TB
    subgraph "PeerManager Singleton"
        START[PeerManager.getInstance]
        PEERLIST[peerList: Record of string, Peer]
        OFFLINE[offlinePeers: Record of string, Peer]

        START --> PEERLIST
        START --> OFFLINE
    end

    subgraph "Peer Structure"
        PEER[Peer Object]
        PEER --> CONNECTION[connection: string URL]
        PEER --> IDENTITY[identity: publicKey hex]
        PEER --> VERIFICATION[verification: status, message, timestamp]
        PEER --> SYNC[sync: status, block, block_hash]
        PEER --> STATUS[status: online, timestamp, ready]
    end

    subgraph "Initialization"
        LOAD[loadPeerList]
        FILE[demos_peer.json file]
        BOOTSTRAP[peerBootstrap routine]

        LOAD --> FILE
        FILE --> BOOTSTRAP
        BOOTSTRAP --> CREATEPEERS[Create Peer objects]
        CREATEPEERS --> ADDPEERS[Add to peerList]
    end

    subgraph "Core Operations"
        ADDPEERS --> OPERATIONS

        OPERATIONS[Core Operations]
        OPERATIONS --> GETPEERS[getPeers: authenticated peers]
        OPERATIONS --> GETALL[getAll: all peers and connections]
        OPERATIONS --> GETONLINE[getOnlinePeers: test and return]
        OPERATIONS --> ADDPEER[addPeer: add or update]
        OPERATIONS --> REMOVEPEER[removeOnlinePeer: delete]
    end

    subgraph "Peer Communication"
        GETONLINE --> SAYHELLO[sayHelloToPeer]
        SAYHELLO --> SIGN[Sign connection string]
        SAYHELLO --> RPC[Send hello_peer RPC]
        RPC --> CALLBACK[helloPeerCallback]

        CALLBACK --> RESPONSE{Response<br/>is 200?}
        RESPONSE -->|yes| ADDONLINE[Add to peerList]
        RESPONSE -->|no| ADDOFFLINE[Add to offlinePeers]
    end

    subgraph "Peer List Persistence"
        ADDPEER --> LOGLIST[logPeerList]
        LOGLIST --> JSONFILE[Write to peer_list.log]
        JSONFILE --> FORMAT[JSON format with connection, identity, auth status]
    end

    subgraph "Sync Data Management"
        ADDONLINE --> UPDATE[updateOurPeerSyncData]
        UPDATE --> OURSYNC[Update our peer sync status]
        OURSYNC --> SYNCFIELDS[syncStatus, lastBlockNumber, lastBlockHash]
    end

    style START fill:#e1f5ff
    style PEERLIST fill:#fff4e1
    style OFFLINE fill:#ffcdd2
    style SAYHELLO fill:#e8f5e9
    style ADDONLINE fill:#c8e6c9
    style ADDOFFLINE fill:#ffcdd2
            </div>
        </section>

        <section id="lifecycle" class="diagram-section lifecycle">
            <h2>2. Peer Lifecycle & Bootstrap Process</h2>

            <div class="key-concepts">
                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>peerBootstrap</strong>: Initial peer discovery on node startup</li>
                    <li><strong>getPeerIdentity</strong>: Verifies cryptographic identity</li>
                    <li><strong>Connection Test</strong>: Ping each peer before adding</li>
                    <li><strong>Fallback</strong>: If no peers, listen for incoming connections</li>
                    <li><strong>Peer Gossip</strong>: Starts after successful bootstrap</li>
                    <li><strong>offlinePeers</strong>: Offline peers scheduled for retry</li>
                </ul>
            </div>

            <div class="mermaid">
flowchart TD
    START([Node Startup])

    START --> LOADFILE[Load demos_peer.json]
    LOADFILE --> FILEEXISTS{File<br/>exists?}

    FILEEXISTS -->|no| CREATEEMPTY[Use empty peer list]
    FILEEXISTS -->|yes| PARSEJSON[Parse JSON peer list]

    CREATEEMPTY --> ADDSELF
    PARSEJSON --> ADDSELF[Add ourselves to peer list]

    ADDSELF --> CREATEOBJECTS[Create Peer objects for each entry]
    CREATEOBJECTS --> BOOTSTRAP[peerBootstrap routine]

    subgraph "Peer Bootstrap Process"
        BOOTSTRAP --> LOOP{For each<br/>peer}

        LOOP -->|more peers| EXTRACTINFO[Extract URL and publicKey]
        LOOP -->|done| CHECKCOUNT

        EXTRACTINFO --> CREATEBLANK[Create blank Peer object]
        CREATEBLANK --> GETIDENTITY[getPeerIdentity routine]

        GETIDENTITY --> CONNECT{Can<br/>connect?}
        CONNECT -->|no| MARKOFFLINE[Add to offlinePeers]
        CONNECT -->|yes| VERIFY[Verify cryptographic identity]

        MARKOFFLINE --> LOOP

        VERIFY --> VERIFIED{Identity<br/>verified?}
        VERIFIED -->|no| MARKOFFLINE
        VERIFIED -->|yes| SETCONNECTION[Set connection string]

        SETCONNECTION --> SAYHELLO[sayHelloToPeer]
        SAYHELLO --> HELLORESPONSE{Hello<br/>success?}

        HELLORESPONSE -->|yes| ADDTOPEERLIST[Add to peerList]
        HELLORESPONSE -->|no| ADDTOOFFLINE[Add to offlinePeers]

        ADDTOPEERLIST --> LOOP
        ADDTOOFFLINE --> LOOP
    end

    CHECKCOUNT{Valid peers<br/>greater than 0?}
    CHECKCOUNT -->|yes| SUCCESS[Bootstrap successful]
    CHECKCOUNT -->|no| LISTEN[Listen for incoming connections]

    SUCCESS --> STARTGOSSIP[Start peer gossip routine]
    LISTEN --> WAIT[Wait for peers to connect]

    STARTGOSSIP --> CONSENSUS[Ready for consensus]
    WAIT --> INCOMING[Process incoming hello_peer]
    INCOMING --> ADDNEWPEER[Add new peers as they connect]
    ADDNEWPEER --> CONSENSUS

    style START fill:#e1f5ff
    style BOOTSTRAP fill:#fff4e1
    style ADDTOPEERLIST fill:#c8e6c9
    style MARKOFFLINE fill:#ffcdd2
    style SUCCESS fill:#c8e6c9
    style LISTEN fill:#ffe0b2
            </div>
        </section>

        <section id="handshake" class="diagram-section handshake">
            <h2>3. Hello Peer Handshake Protocol</h2>

            <div class="key-concepts">
                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Cryptographic Proof</strong>: Sign connection string with ed25519</li>
                    <li><strong>HelloPeerRequest</strong>: Contains URL, publicKey, signature, syncData</li>
                    <li><strong>Signature Verification</strong>: Remote peer verifies before accepting</li>
                    <li><strong>Sync Data Exchange</strong>: Both peers share blockchain state</li>
                    <li><strong>Retry Logic</strong>: 3 retries with 250ms delay</li>
                    <li><strong>Mutual Authentication</strong>: Both peers verify each other</li>
                </ul>
            </div>

            <div class="mermaid">
sequenceDiagram
    participant Node as Local Node
    participant PM as PeerManager
    participant Crypto as Cryptography
    participant Remote as Remote Peer
    participant GCR as GCR System

    Note over Node,Remote: Peer wants to establish connection

    Node->>PM: sayHelloToPeer(peer)
    PM->>PM: Increment peerRoutineRunning counter

    PM->>Node: Get our connection string (exposedUrl)
    PM->>Crypto: Sign connection string with ed25519
    Crypto->>PM: Return signature

    PM->>PM: Build HelloPeerRequest
    Note right of PM: url: our connection string<br/>publicKey: our hex key<br/>signature: type and data<br/>syncData: block, hash, status

    PM->>Remote: RPC: hello_peer(request)
    Note right of PM: Retry: 3 times, 250ms delay

    Remote->>Remote: Receive hello_peer request
    Remote->>Crypto: Verify signature against publicKey

    alt Signature Valid
        Remote->>GCR: Check if peer is known
        Remote->>Remote: Update or add peer to peerList
        Remote->>Remote: Update sync data from request
        Remote->>PM: Response 200 with success
        Note left of Remote: msg: "Hello received"<br/>syncData: our sync info
    else Signature Invalid
        Remote->>PM: Response 400 with error
    end

    PM->>PM: helloPeerCallback(response, peer)

    alt Response is 200
        PM->>PM: Update peer.sync from response
        PM->>PM: addPeer(peer) to peerList
        PM->>PM: removeOfflinePeer(peer)
        Note right of PM: Peer is online and authenticated
    else Response not 200
        PM->>PM: addOfflinePeer(peer)
        PM->>PM: removeOnlinePeer(peer)
        Note right of PM: Peer is offline or failed
    end

    PM->>PM: Decrement peerRoutineRunning counter
    PM->>Node: Return peer status
            </div>
        </section>

        <section id="gossip" class="diagram-section gossip">
            <h2>4. Peer Gossip Protocol</h2>

            <div class="key-concepts">
                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Hash-Based Comparison</strong>: SHA256 of ordered peer list</li>
                    <li><strong>Selective Sync</strong>: Only request full list from different peers</li>
                    <li><strong>Random Selection</strong>: Gossip with max 10 random peers</li>
                    <li><strong>Batch Processing</strong>: Process peers in batches of 10</li>
                    <li><strong>Merge Strategy</strong>: Higher block number wins</li>
                    <li><strong>Event Loop Yield</strong>: setImmediate between batches</li>
                </ul>
            </div>

            <div class="mermaid">
flowchart TD
    START([peerGossip triggered])

    START --> GUARD{inPeerGossip<br/>flag set?}
    GUARD -->|yes| RETURN[Return - already running]
    GUARD -->|no| SETFLAG[Set inPeerGossip true]

    SETFLAG --> GETPEERS[Get all peers from PeerManager]
    GETPEERS --> CHECKEMPTY{Peers<br/>greater than 0?}

    CHECKEMPTY -->|no| CLEANUP[Set inPeerGossip false]
    CHECKEMPTY -->|yes| SELECT[Select peers for gossip]

    SELECT --> COUNTCHECK{Peer count<br/>less or equal maxGossipPeers?}
    COUNTCHECK -->|yes| SELECTALL[Select all peers]
    COUNTCHECK -->|no| SELECTRANDOM[Select 10 random peers]

    SELECTALL --> ORDEROUS
    SELECTRANDOM --> ORDEROUS[Order our peer list by identity]

    ORDEROUS --> HASHOURS[SHA256 hash of ordered list]
    HASHOURS --> REQUESTHASHES[Request peer list hashes from selected peers]

    subgraph "Hash Request Process"
        REQUESTHASHES --> SENDREQ[Send getPeerlistHash RPC to each]
        SENDREQ --> WAITRESP[Wait for all responses]
        WAITRESP --> PROCESSRESP[Process responses]
    end

    PROCESSRESP --> COMPARE{For each<br/>response}

    COMPARE -->|more| CHECKHASH{Hash matches<br/>our hash?}
    COMPARE -->|done| CHECKDIFF

    CHECKHASH -->|yes| SKIP[Skip - peer list same]
    CHECKHASH -->|no| MARKDIFF[Mark peer as different]

    SKIP --> COMPARE
    MARKDIFF --> COMPARE

    CHECKDIFF{Different peers<br/>exist?}
    CHECKDIFF -->|no| CLEANUP
    CHECKDIFF -->|yes| REQUESTLISTS[Request full peer lists]

    subgraph "Peer List Sync Process"
        REQUESTLISTS --> SENDGETLIST[Send getPeerlist RPC to different peers]
        SENDGETLIST --> WAITLISTS[Wait for all peer list responses]
        WAITLISTS --> FILTERLISTS[Filter successful responses]
        FILTERLISTS --> CONVERTPEERS[Convert to Peer objects]
    end

    CONVERTPEERS --> ADDOURS[Add our peer list to array]
    ADDOURS --> MERGE[mergePeerlists routine]

    subgraph "Merge Process"
        MERGE --> CREATEMAP[Create Map by identity]
        CREATEMAP --> FLATTEN[Flatten all peer lists]
        FLATTEN --> BATCHLOOP{Process in<br/>batches of 10}

        BATCHLOOP -->|more| PROCESSBATCH[Process batch]
        PROCESSBATCH --> CHECKEXIST{Peer<br/>exists?}

        CHECKEXIST -->|yes| COMPAREBLOCK{New block<br/>greater than existing?}
        COMPAREBLOCK -->|yes| UPDATEPEER[Update sync data]
        COMPAREBLOCK -->|no| SKIPUPDATE[Keep existing]

        CHECKEXIST -->|no| ADDNEWPEER[Add new peer to map]

        UPDATEPEER --> YIELD[Yield to event loop]
        SKIPUPDATE --> YIELD
        ADDNEWPEER --> YIELD
        YIELD --> BATCHLOOP

        BATCHLOOP -->|done| SORTMAP[Sort by identity]
        SORTMAP --> SETPEERS[PeerManager.setPeers]
    end

    SETPEERS --> CLEANUP
    CLEANUP --> END([Gossip complete])
    RETURN -.-> END

    style START fill:#e1f5ff
    style HASHOURS fill:#fff4e1
    style MERGE fill:#e8f5e9
    style SETPEERS fill:#c8e6c9
    style CLEANUP fill:#f3e5f5
            </div>
        </section>

        <section id="entrance" class="diagram-section entrance">
            <h2>5. Validator Entrance & Management</h2>

            <div class="key-concepts">
                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>minToStake</strong>: 10^25 minimum stake requirement</li>
                    <li><strong>Validation Checks</strong>: Amount, blacklist, kick history</li>
                    <li><strong>GCR Integration</strong>: Validator status stored in GCR</li>
                    <li><strong>Status 2</strong>: Active validator status</li>
                    <li><strong>Connection Test</strong>: Ping validator to check online</li>
                    <li><strong>Shard Eligibility</strong>: Online synced validators selected for consensus</li>
                </ul>
            </div>

            <div class="mermaid">
flowchart TD
    START([Validator Entrance Request])

    START --> CREATETX[Create validator entrance transaction]
    CREATETX --> TXCONTENT[Transaction with amount to stake]

    TXCONTENT --> VALIDATE[ValidatorsManagement.manageValidatorEntranceTx]

    subgraph "Validation Checks"
        VALIDATE --> CHECK1{Amount greater or equal<br/>minToStake?}
        CHECK1 -->|no| FAIL1[isEntranceValid false]
        CHECK1 -->|yes| CHECK2

        CHECK2[Check if not already staking]
        CHECK2 --> TODO1[TODO: Implement check]

        TODO1 --> CHECK3[Check if not blacklisted]
        CHECK3 --> TODO2[TODO: Implement check]

        TODO2 --> CHECK4[Check if never kicked]
        CHECK4 --> TODO3[TODO: Implement check]

        TODO3 --> SUCCESS[isEntranceValid true]
    end

    FAIL1 --> REJECTTX[Reject transaction]
    SUCCESS --> ACCEPTTX[Accept transaction]

    ACCEPTTX --> ADDTOCHAIN[Add transaction to chain]
    ADDTOCHAIN --> UPDATEGCR[Update GCR validator status]

    subgraph "GCR Validator Entry"
        UPDATEGCR --> CREATERECORD[Create Validators table entry]
        CREATERECORD --> FIELDS[Set fields]

        FIELDS --> ADDRESS[address: publicKey]
        FIELDS --> STATUSFIELD[status: 2 for active]
        FIELDS --> CONNECTIONURL[connection_url: node URL]
        FIELDS --> STAKED[staked: amount]
        FIELDS --> FIRSTSEEN[first_seen: block number]
        FIELDS --> VALIDAT[valid_at: block number]
        FIELDS --> STAKE[stake: normalized amount]
    end

    STAKE --> SAVEDB[Save to database]
    SAVEDB --> CHECKSTATUS[isValidatorActive check]

    subgraph "Validator Status Check"
        CHECKSTATUS --> GETGCR[GCR.getGCRValidatorStatus]
        GETGCR --> READSTATUS[Read status field]
        READSTATUS --> COMPARE{status is 2?}

        COMPARE -->|yes| ACTIVE[Validator is active]
        COMPARE -->|no| INACTIVE[Validator is inactive]
    end

    ACTIVE --> ELIGIBLE[Eligible for consensus shard selection]
    INACTIVE --> NOTELIGIBLE[Not eligible for consensus]

    subgraph "Online Status Management"
        ELIGIBLE --> MANAGEONLINE[manageValidatorOnlineStatus]
        MANAGEONLINE --> GETCONNECTION[Get connection_string from GCR]
        GETCONNECTION --> TESTCONNECTION[TODO: Connection test]
        TESTCONNECTION --> PINGVALIDATOR[Ping validator endpoint]

        PINGVALIDATOR --> PINGRESPONSE{Response<br/>received?}
        PINGRESPONSE -->|yes| MARKONLINE[Mark as online in PeerManager]
        PINGRESPONSE -->|no| MARKOFFLINE[Mark as offline in PeerManager]
    end

    MARKONLINE --> SHARDELIGIBLE[Available for shard selection]
    MARKOFFLINE --> RETRY[Add to offline peers for retry]

    style START fill:#e1f5ff
    style SUCCESS fill:#c8e6c9
    style FAIL1 fill:#ffcdd2
    style ACTIVE fill:#c8e6c9
    style INACTIVE fill:#ffe0b2
    style SHARDELIGIBLE fill:#c8e6c9
            </div>
        </section>

        <section id="rpc" class="diagram-section rpc">
            <h2>6. Peer Connection & RPC System</h2>

            <div class="key-concepts">
                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>JSON-RPC</strong>: All peer communication via RPC</li>
                    <li><strong>Authentication</strong>: Optional signature in headers</li>
                    <li><strong>Timeout</strong>: 3000ms per request</li>
                    <li><strong>longCall</strong>: Retry logic with sleep between attempts</li>
                    <li><strong>Local Node Detection</strong>: Use internal connection for self</li>
                    <li><strong>Error Handling</strong>: Return 500 on network failure</li>
                </ul>
            </div>

            <div class="mermaid">
sequenceDiagram
    participant Caller
    participant Peer
    participant Crypto
    participant Axios as HTTP Client
    participant Remote as Remote Node

    Note over Caller,Remote: Peer.call() - Generic RPC Call

    Caller->>Peer: call(request, isAuthenticated)
    Peer->>Peer: Log: Making RPC call

    alt isAuthenticated is true
        Peer->>Crypto: getIdentity(signingAlgorithm)
        Crypto->>Peer: Return publicKey
        Peer->>Peer: Convert to hex

        Peer->>Crypto: sign(signingAlgorithm, publicKey)
        Crypto->>Peer: Return signature
        Peer->>Peer: Convert signature to hex
    else isAuthenticated is false
        Peer->>Peer: pubkey = empty
        Peer->>Peer: signature = empty
    end

    Peer->>Peer: Check if peer is local node
    alt isLocalNode is true
        Peer->>Peer: Use internal connection string
    else isLocalNode is false
        Peer->>Peer: Use external connection string
    end

    Peer->>Axios: POST request with headers
    Note right of Peer: Headers:<br/>Content-Type: application/json<br/>identity: algorithm:pubkey<br/>signature: hex signature<br/>Timeout: 3000ms

    Axios->>Remote: HTTP POST with JSON-RPC request
    Remote->>Remote: Process request
    Remote->>Remote: Verify signature if authenticated
    Remote->>Remote: Execute method
    Remote->>Axios: Return RPCResponse

    alt Request successful
        Axios->>Peer: Response with status 200
        Peer->>Peer: Check response.data.result
        alt result is 200
            Peer->>Peer: Log: Response OK
        else result not 200
            Peer->>Peer: Log: Response not OK
        end
        Peer->>Caller: Return response.data
    else Request failed
        Axios->>Peer: Throw error
        Peer->>Peer: Log error with details
        Peer->>Caller: Return error response
        Note left of Peer: result: 500<br/>response: error<br/>require_reply: false
    end

    Note over Caller,Remote: Peer.longCall() - Call with Retries

    Caller->>Peer: longCall(request, auth, sleepTime, retries)
    Peer->>Peer: tries = 0

    loop While tries less than retries
        Peer->>Peer: call(request, auth)
        Peer->>Peer: Check response.result

        alt result is 200 or in allowedErrors
            Peer->>Caller: Return response immediately
        else result is error
            Peer->>Peer: Increment tries
            Peer->>Peer: Sleep for sleepTime ms
        end
    end

    Peer->>Peer: Max retries reached
    Peer->>Peer: Log error with method name
    Peer->>Caller: Return error response
    Note left of Peer: result: 400<br/>response: "Max retries reached"<br/>extra: last response
            </div>
        </section>

        <section id="status" class="diagram-section status">
            <h2>7. Online/Offline Status Management</h2>

            <div class="key-concepts">
                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Peer States</strong>: Unknown, Testing, Online, Offline</li>
                    <li><strong>Signature Verification</strong>: Required to transition to Online</li>
                    <li><strong>Consensus Timeout</strong>: 15s secretary wait triggers offline detection</li>
                    <li><strong>Retry Queue</strong>: Offline peers scheduled for reconnection</li>
                    <li><strong>Gossip Updates</strong>: Peer status updated from gossip protocol</li>
                    <li><strong>Ready Status</strong>: synced AND verified AND online</li>
                </ul>
            </div>

            <div class="mermaid">
stateDiagram-v2
    [*] --> Unknown: Peer discovered

    state "Unknown Status" as Unknown {
        [*] --> NotTested
        NotTested: Peer in demos_peer.json
        NotTested: No connection attempted yet
    }

    Unknown --> Testing: peerBootstrap or sayHelloToPeer

    state "Connection Testing" as Testing {
        [*] --> SendPing
        SendPing: Send hello_peer RPC
        SendPing --> WaitResponse: Wait for response (3 retries, 250ms)
        WaitResponse --> CheckSignature: Verify cryptographic signature

        state CheckSignature {
            [*] --> ValidSignature
            [*] --> InvalidSignature

            ValidSignature: Signature matches publicKey
            InvalidSignature: Signature verification failed
        }
    }

    Testing --> Online: Signature valid and response 200
    Testing --> Offline: No response or invalid signature

    state "Online" as Online {
        [*] --> InPeerList
        InPeerList: Added to peerList
        InPeerList --> UpdateSync: Periodically update sync data
        UpdateSync --> CheckReady: Check if ready for consensus

        state CheckReady {
            [*] --> Ready
            [*] --> NotReady

            Ready: synced and verified and online
            NotReady: missing one or more requirements
        }

        CheckReady --> InPeerList
    }

    state "Offline" as Offline {
        [*] --> InOfflineList
        InOfflineList: Added to offlinePeers
        InOfflineList --> ScheduleRetry: Add to retry queue
        ScheduleRetry --> WaitRetry: Wait for retry interval
        WaitRetry --> [*]: Will retry later
    }

    Online --> Offline: Timeout in consensus or RPC failure
    Offline --> Testing: Retry connection after interval

    state "Consensus Timeout Detection" as ConsensusTimeout {
        [*] --> SecretaryWait
        SecretaryWait: Secretary waits for member phase
        SecretaryWait --> Timeout: 15s timeout expires
        Timeout --> PingMember: Secretary pings member
        PingMember --> NoResponse: Member does not respond
        NoResponse --> RemoveFromShard: Remove from current shard
        RemoveFromShard --> [*]: Mark as offline
    }

    state "Gossip Update" as GossipUpdate {
        [*] --> ReceivePeerList
        ReceivePeerList: Peer list received from gossip
        ReceivePeerList --> ComparePeer: Check peer in our list

        state ComparePeer {
            [*] --> NewerSync
            [*] --> OlderSync

            NewerSync: Received peer has higher block
            OlderSync: Our peer has higher block
        }

        ComparePeer --> UpdateOrKeep: Update or keep existing
    }

    Online --> ConsensusTimeout: Consensus routine running
    ConsensusTimeout --> Offline

    Online --> GossipUpdate: Peer gossip running
    Offline --> GossipUpdate: Peer gossip running
    GossipUpdate --> Online: Peer reported as online
    GossipUpdate --> Offline: Peer reported as offline

    note right of Online
        Online peers are:
        - In peerList
        - Authenticated (verified signature)
        - Have sync data
        - Can participate in consensus
    end note

    note right of Offline
        Offline peers are:
        - In offlinePeers
        - Failed connection or signature
        - Scheduled for retry
        - Cannot participate in consensus
    end note
            </div>
        </section>

        <section id="sync" class="diagram-section sync">
            <h2>8. Sync Status Tracking</h2>

            <div class="key-concepts">
                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Sync Data Fields</strong>: status (boolean), block (number), block_hash (string)</li>
                    <li><strong>Our Sync Data</strong>: Shared via hello_peer to all peers</li>
                    <li><strong>Gossip Merge</strong>: Higher block number wins during merge</li>
                    <li><strong>Consensus Filter</strong>: Only peers with sync.status=true eligible for shard</li>
                    <li><strong>Phase Catch-up</strong>: Secretary releases lagging members immediately</li>
                    <li><strong>CVSA Input</strong>: Sync status used in shard selection</li>
                </ul>
            </div>

            <div class="mermaid">
flowchart TD
    START([Sync Status Management])

    START --> OURNODE[Our Node Sync Data]

    subgraph "Our Sync Data"
        OURNODE --> SHAREDSTATE[getSharedState]
        SHAREDSTATE --> SYNCSTATUS[syncStatus: boolean]
        SHAREDSTATE --> LASTBLOCK[lastBlockNumber: number]
        SHAREDSTATE --> LASTHASH[lastBlockHash: string]
    end

    LASTHASH --> UPDATE[updateOurPeerSyncData]

    subgraph "Update Our Peer Entry"
        UPDATE --> GETOURPEER[Get our peer from peerList]
        GETOURPEER --> SETFIELDS[Set sync fields]

        SETFIELDS --> SETSTATUS[peer.sync.status = syncStatus]
        SETFIELDS --> SETBLOCK[peer.sync.block = lastBlockNumber]
        SETFIELDS --> SETHASH[peer.sync.block_hash = lastBlockHash]
    end

    SETHASH --> BROADCAST[Broadcast in hello_peer]

    subgraph "Sending Sync Data"
        BROADCAST --> BUILDREQUEST[Build HelloPeerRequest]
        BUILDREQUEST --> ADDSYNC[Add syncData field]

        ADDSYNC --> SYNCOBJ["syncData:<br/>block, block_hash, status"]
        SYNCOBJ --> SENDTOPEERS[Send to all peers in hello_peer]
    end

    SENDTOPEERS --> RECEIVE[Receive sync data from peers]

    subgraph "Receiving Sync Data"
        RECEIVE --> HELLOCALLBACK[helloPeerCallback]
        HELLOCALLBACK --> EXTRACTSYNC[Extract response.extra.syncData]

        EXTRACTSYNC --> UPDATESYNC{syncData<br/>present?}
        UPDATESYNC -->|yes| SETPEER[peer.sync = response syncData]
        UPDATESYNC -->|no| SKIPSYNC[Keep existing sync data]

        SETPEER --> ADDPEER[addPeer to peerList]
    end

    ADDPEER --> MERGE[Merge from peer gossip]

    subgraph "Gossip Sync Merge"
        MERGE --> COMPARESYNC{Received peer<br/>block greater?}

        COMPARESYNC -->|yes| UPDATEFROMGOSSIP[Update sync fields]
        COMPARESYNC -->|no| KEEPEXISTING[Keep our data]

        UPDATEFROMGOSSIP --> SETGOSSIPFIELDS[Set block, block_hash, status]
    end

    SETGOSSIPFIELDS --> CONSENSUS[Use in consensus]
    KEEPEXISTING --> CONSENSUS

    subgraph "Consensus Shard Selection"
        CONSENSUS --> GETONLINE[getOnlinePeers]
        GETONLINE --> FILTER[Filter by sync.status is true]

        FILTER --> SYNCED[Synced peers only]
        SYNCED --> SHARD[Eligible for shard selection]

        SHARD --> CVSA[Used in CVSA algorithm]
        CVSA --> SELECTED[Deterministic shard members]
    end

    SELECTED --> MONITOR[Monitor during consensus]

    subgraph "Sync Monitoring"
        MONITOR --> CHECKLAG{Peer falls<br/>behind?}

        CHECKLAG -->|yes| PHASE[Phase-based catch-up]
        CHECKLAG -->|no| CONTINUE[Continue in shard]

        PHASE --> IMMEDIATE[Secretary releases immediately]
        IMMEDIATE --> CATCHUP[Member catches up to current phase]
        CATCHUP --> REJOIN[Rejoins at current phase]
    end

    REJOIN --> END([Sync tracking complete])

    style START fill:#e1f5ff
    style UPDATE fill:#fff4e1
    style FILTER fill:#e8f5e9
    style SELECTED fill:#c8e6c9
    style IMMEDIATE fill:#ffe0b2
            </div>
        </section>

        <section id="points" class="diagram-section points">
            <h2>9. Point/Reputation System</h2>

            <div class="key-concepts">
                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>GCR Storage</strong>: Points stored in GCR_Main.points field</li>
                    <li><strong>Point Values</strong>: Web3=0.5, Twitter=2, GitHub=1, Telegram=1, Discord=1</li>
                    <li><strong>Identity Hooks</strong>: IncentiveManager called on identity link/unlink</li>
                    <li><strong>Referral System</strong>: Bonus points for referring new users</li>
                    <li><strong>Twitter Follow Bonus</strong>: Extra point for following @DemosBlockchain</li>
                    <li><strong>One-Time Award</strong>: Each identity type awarded once</li>
                </ul>
            </div>

            <div class="mermaid">
flowchart TD
    START([User Reputation Management])

    START --> GCRSTORAGE[Points stored in GCR_Main table]

    subgraph "GCR Points Structure"
        GCRSTORAGE --> TOTALPOINTS[totalPoints: number]
        GCRSTORAGE --> BREAKDOWN[breakdown object]

        BREAKDOWN --> WEB3[web3Wallets: Map of chain to points]
        BREAKDOWN --> SOCIAL[socialAccounts: twitter, github, telegram, discord]
        BREAKDOWN --> REFERRALS[referrals: number]
        BREAKDOWN --> DEMOS[demosFollow: number]

        GCRSTORAGE --> LASTUPDATED[lastUpdated: Date]
    end

    LASTUPDATED --> POINTVALUES[Point Values Configuration]

    subgraph "Point Award Values"
        POINTVALUES --> LINKWEB3[LINK_WEB3_WALLET: 0.5]
        POINTVALUES --> LINKTWITTER[LINK_TWITTER: 2]
        POINTVALUES --> LINKGITHUB[LINK_GITHUB: 1]
        POINTVALUES --> LINKTELEGRAM[LINK_TELEGRAM: 1]
        POINTVALUES --> LINKDISCORD[LINK_DISCORD: 1]
        POINTVALUES --> FOLLOWDEMOS[FOLLOW_DEMOS: 1]
    end

    LINKDISCORD --> TRIGGER[Incentive Triggers]

    subgraph "Identity Linking Hooks"
        TRIGGER --> IDENTITYLINK[User links identity in GCR]
        IDENTITYLINK --> CALLHOOK[IncentiveManager hook called]

        CALLHOOK --> HOOKTYPE{Hook<br/>type?}

        HOOKTYPE -->|walletLinked| AWARDWEB3[awardWeb3WalletPoints]
        HOOKTYPE -->|twitterLinked| AWARDTWITTER[awardTwitterPoints]
        HOOKTYPE -->|githubLinked| AWARDGITHUB[awardGithubPoints]
        HOOKTYPE -->|telegramLinked| AWARDTELEGRAM[awardTelegramPoints]
        HOOKTYPE -->|discordLinked| AWARDDISCORD[awardDiscordPoints]
    end

    AWARDDISCORD --> CHECKDUPE[Check if already awarded]

    subgraph "Award Process"
        CHECKDUPE --> GETUSER[getUserPointsInternal]
        GETUSER --> CHECKEXIST{Points already<br/>exist for this identity?}

        CHECKEXIST -->|yes| SKIPPOINTS[Skip - points already awarded]
        CHECKEXIST -->|no| ADDPOINTS[addPointsToGCR]

        ADDPOINTS --> UPDATETOTAL[totalPoints plus equals points]
        ADDPOINTS --> UPDATEBREAKDOWN[Update breakdown field]
        ADDPOINTS --> SETTIMESTAMP[Set lastUpdated to now]
    end

    SETTIMESTAMP --> REFERRALCHECK[Check referral code]

    subgraph "Referral Processing"
        REFERRALCHECK --> HASREFERRAL{Referral code<br/>provided?}

        HASREFERRAL -->|yes| CHECKELIGIBLE{User<br/>eligible?}
        HASREFERRAL -->|no| SAVE

        CHECKELIGIBLE -->|yes| PROCESSREFERRAL[Referrals.processReferral]
        CHECKELIGIBLE -->|no| SAVE

        PROCESSREFERRAL --> FINDREFERRER[Find referrer by code]
        FINDREFERRER --> REFERREREXISTS{Referrer<br/>exists?}

        REFERREREXISTS -->|yes| AWARDREFERRER[Award points to referrer]
        REFERREREXISTS -->|no| SAVE

        AWARDREFERRER --> UPDATECOUNT[Increment totalReferrals]
        UPDATECOUNT --> ADDREFEREE[Add referee to referrals array]
        ADDREFEREE --> SETREFERRED[Set referredBy for user]
    end

    SETREFERRED --> SAVE[Save GCR_Main to database]
    SAVE --> TWITTERCHECK[Check Twitter follow]

    subgraph "Demos Follow Bonus"
        TWITTERCHECK --> HASTWITTERID{Has Twitter<br/>identity?}

        HASTWITTERID -->|yes| CHECKFOLLOW[Twitter.checkFollow username]
        HASTWITTERID -->|no| RESPONSE

        CHECKFOLLOW --> FOLLOWING{Is following<br/>@DemosBlockchain?}

        FOLLOWING -->|yes| AWARDFOLLOW[Award FOLLOW_DEMOS points]
        FOLLOWING -->|no| RESPONSE

        AWARDFOLLOW --> ADDTOBREAKDOWN[breakdown.demosFollow plus equals 1]
        ADDTOBREAKDOWN --> ADDTOTOTAL[totalPoints plus equals 1]
    end

    ADDTOTOTAL --> RESPONSE[Return RPCResponse]
    SKIPPOINTS --> RESPONSE

    RESPONSE --> GETPOINTS[getPoints API]

    subgraph "Points Retrieval"
        GETPOINTS --> FETCHGCR[Fetch GCR_Main by pubkey]
        FETCHGCR --> FETCHIDENTITIES[Fetch linked identities from IdentityManager]

        FETCHIDENTITIES --> BUILDRESPONSE[Build UserPoints response]

        BUILDRESPONSE --> RESPFIELDS[Response fields]
        RESPFIELDS --> USERID[userId: pubkey]
        RESPFIELDS --> REFERRALCODE[referralCode: string]
        RESPFIELDS --> TOTALPOINTSRESP[totalPoints: number]
        RESPFIELDS --> BREAKDOWNRESP[breakdown: object]
        RESPFIELDS --> LINKEDWALLETS[linkedWallets: array of addresses]
        RESPFIELDS --> LINKEDSOCIALS[linkedSocials: twitter, discord]
        RESPFIELDS --> LASTUPDATEDRESP[lastUpdated: Date]
        RESPFIELDS --> FLAGGED[flagged and flaggedReason if any]
    end

    FLAGGED --> RETURN[Return to client]
    RETURN --> END([Points system complete])

    style START fill:#e1f5ff
    style GCRSTORAGE fill:#fff4e1
    style ADDPOINTS fill:#e8f5e9
    style AWARDREFERRER fill:#c8e6c9
    style AWARDFOLLOW fill:#c8e6c9
    style RETURN fill:#f3e5f5
            </div>
        </section>

        <section id="flow" class="diagram-section flow">
            <h2>10. Complete Peer-to-Validator Flow</h2>

            <div class="key-concepts">
                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Bootstrap</strong>: Discover and authenticate initial peers</li>
                    <li><strong>Sync</strong>: Download and validate blockchain from peers</li>
                    <li><strong>Gossip</strong>: Continuously update peer list from network</li>
                    <li><strong>Validator Entrance</strong>: Stake tokens to become validator</li>
                    <li><strong>Consensus Participation</strong>: Selected via CVSA, execute PoRBFT</li>
                    <li><strong>Reputation</strong>: Earn points for participation and identity linking</li>
                </ul>
            </div>

            <div class="mermaid">
flowchart TD
    START([New Node Joins Network])

    START --> GENESIS[Load genesis block]
    GENESIS --> KEYPAIR[Generate or load ed25519 keypair]
    KEYPAIR --> PUBLICKEY[Derive publicKey hex]

    PUBLICKEY --> LOADPEERS[Load demos_peer.json]
    LOADPEERS --> BOOTSTRAP[Run peerBootstrap]

    subgraph "Peer Discovery"
        BOOTSTRAP --> TESTPEERS[Test each peer connection]
        TESTPEERS --> VERIFYPEERS[Verify cryptographic identities]
        VERIFYPEERS --> HELLOS[Send hello_peer to all]
        HELLOS --> AUTHENTICATED[Build authenticated peer list]
    end

    AUTHENTICATED --> STARTGOSSIP[Start peer gossip routine]

    subgraph "Peer Synchronization"
        STARTGOSSIP --> GOSSIPHASH[Hash our peer list]
        GOSSIPHASH --> SENDHASHREQUESTS[Send hash to 10 random peers]
        SENDHASHREQUESTS --> COMPAREHASHES[Compare hashes]
        COMPAREHASHES --> REQUESTLISTS[Request full lists from different peers]
        REQUESTLISTS --> MERGELISTS[Merge all peer lists]
        MERGELISTS --> UPDATEPEERLIST[Update local peer list]
    end

    UPDATEPEERLIST --> STARTSYNC[Start blockchain sync]

    subgraph "Blockchain Synchronization"
        STARTSYNC --> GETLASTBLOCK[Get our last block number]
        GETLASTBLOCK --> QUERYPEERS[Query peers for their last block]
        QUERYPEERS --> FINDHIGHEST[Find peer with highest block]
        FINDHIGHEST --> REQUESTBLOCKS[Request missing blocks]
        REQUESTBLOCKS --> VALIDATEBLOCKS[Validate and add blocks]
        VALIDATEBLOCKS --> UPDATESYNCSTATUS[Update sync.status true]
    end

    UPDATESYNCSTATUS --> BROADCASTSYNC[Broadcast sync status in hello_peer]
    BROADCASTSYNC --> ELIGIBLE[Eligible for consensus]

    ELIGIBLE --> STAKEDECISION{Want to become<br/>validator?}

    STAKEDECISION -->|no| PARTICIPATEP2P[Participate as peer only]
    STAKEDECISION -->|yes| CREATESTAKETX[Create validator entrance tx]

    subgraph "Validator Entrance"
        CREATESTAKETX --> SETAMOUNT[Set amount greater or equal minToStake]
        SETAMOUNT --> SIGNTX[Sign transaction]
        SIGNTX --> BROADCASTTX[Broadcast to network]
        BROADCASTTX --> VALIDATETX[ValidatorsManagement.manageValidatorEntranceTx]

        VALIDATETX --> CHECKS{All checks<br/>pass?}
        CHECKS -->|no| REJECTTX[Transaction rejected]
        CHECKS -->|yes| ACCEPTTX[Transaction accepted]

        ACCEPTTX --> ADDTOCHAIN[Add to blockchain]
        ADDTOCHAIN --> UPDATEGCR[Update GCR validators table]
        UPDATEGCR --> SETSTATUS[Set status to 2 for active]
    end

    SETSTATUS --> NOWVALIDATOR[Now a validator]

    subgraph "Consensus Participation"
        NOWVALIDATOR --> CONSENSUSROUND[Wait for consensus round]
        CONSENSUSROUND --> GETLASTBLOCKNUM[Get lastBlockNumber]
        GETLASTBLOCKNUM --> CVSA[Calculate CVSA seed]

        CVSA --> GETONLINEPEERS[Get online synced peers]
        GETONLINEPEERS --> FILTERSYNCED[Filter by sync.status true]
        FILTERSYNCED --> SHARDSELECT[Deterministic shard selection]

        SHARDSELECT --> INSHARD{Are we in<br/>shard?}

        INSHARD -->|no| WAITNEXTBLOCK[Wait for next block]
        INSHARD -->|yes| PARTICIPATECONSENSUS[Participate in PoRBFT]

        PARTICIPATECONSENSUS --> PHASES[Execute 7 validation phases]
        PHASES --> VOTE[Vote on block]
        VOTE --> BLOCKRESULT{Block<br/>valid?}

        BLOCKRESULT -->|yes| FINALIZE[Finalize block]
        BLOCKRESULT -->|no| ROLLBACK[Rollback GCR edits]

        FINALIZE --> UPDATEOURPOINTS[Earn reputation points]
        UPDATEOURPOINTS --> WAITNEXTROUND

        ROLLBACK --> WAITNEXTROUND[Wait for next consensus round]
        WAITNEXTBLOCK --> WAITNEXTROUND
    end

    WAITNEXTROUND --> CONSENSUSROUND

    PARTICIPATEP2P --> RELAY[Relay transactions and blocks]
    RELAY --> HELLOPEER[Respond to hello_peer]
    HELLOPEER --> GOSSIPPART[Participate in gossip]
    GOSSIPPART --> SYNCHELP[Help new peers sync]

    REJECTTX --> PARTICIPATEP2P

    style START fill:#e1f5ff
    style AUTHENTICATED fill:#fff4e1
    style UPDATESYNCSTATUS fill:#e8f5e9
    style SETSTATUS fill:#c8e6c9
    style PARTICIPATECONSENSUS fill:#c8e6c9
    style FINALIZE fill:#c8e6c9
    style ROLLBACK fill:#ffcdd2
            </div>
        </section>

        <div class="file-references">
            <h3>üìÅ Key File References</h3>

            <h4>Peer Management Files</h4>
            <ul>
                <li><strong>PeerManager</strong>: <code>src/libs/peer/PeerManager.ts</code> (424 lines)</li>
                <li><strong>Peer</strong>: <code>src/libs/peer/Peer.ts</code> (347 lines)</li>
                <li><strong>Peer Bootstrap</strong>: <code>src/libs/peer/routines/peerBootstrap.ts</code> (104 lines)</li>
                <li><strong>Peer Gossip</strong>: <code>src/libs/peer/routines/peerGossip.ts</code> (285 lines)</li>
            </ul>

            <h4>Validator Management Files</h4>
            <ul>
                <li><strong>Validators Management</strong>: <code>src/libs/blockchain/routines/validatorsManagement.ts</code> (43 lines)</li>
                <li><strong>Validators Entity</strong>: <code>src/model/entities/Validators.ts</code> (26 lines)</li>
            </ul>

            <h4>Point/Reputation System Files</h4>
            <ul>
                <li><strong>Point System</strong>: <code>src/features/incentive/PointSystem.ts</code> (983 lines)</li>
                <li><strong>Incentive Manager</strong>: <code>src/libs/blockchain/gcr/gcr_routines/IncentiveManager.ts</code> (138 lines)</li>
            </ul>
        </div>

        <div class="key-features">
            <h2>Peer & Validator Management Principles</h2>
            <ol>
                <li><strong>Decentralized Peer Discovery</strong>: Gossip protocol ensures all nodes have consistent peer lists</li>
                <li><strong>Cryptographic Authentication</strong>: All peers verified with ed25519 signatures before trust</li>
                <li><strong>Sync-Based Eligibility</strong>: Only synced peers can participate in consensus</li>
                <li><strong>Online/Offline Resilience</strong>: Automatic retry logic for offline peers</li>
                <li><strong>Deterministic Validator Selection</strong>: CVSA algorithm ensures same shard selection</li>
                <li><strong>Reputation-Based Incentives</strong>: Points for identity linking stored in GCR</li>
                <li><strong>Minimal Stake Requirement</strong>: 10^25 minimum to become validator</li>
                <li><strong>Peer List Persistence</strong>: demos_peer.json and peer_list.log for recovery</li>
                <li><strong>RPC-Based Communication</strong>: All peer communication via JSON-RPC</li>
                <li><strong>Separation of Concerns</strong>: Peers handle networking, validators handle consensus</li>
            </ol>
        </div>

        <footer>
            <p>Generated with ‚ù§Ô∏è for Demos Blockchain</p>
            <p>Peer & Validator Management - Interactive Diagram Documentation</p>
        </footer>
    </div>

    <button class="print-btn" onclick="window.print()">üñ®Ô∏è Print</button>

    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            securityLevel: 'loose',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            },
            sequence: {
                useMaxWidth: true,
                wrap: true
            },
            stateDiagram: {
                useMaxWidth: true
            }
        });

        // Smooth scrolling for navigation links
        document.querySelectorAll('nav a').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                target.scrollIntoView({ behavior: 'smooth', block: 'start' });
            });
        });

        // Highlight active section in navigation
        window.addEventListener('scroll', () => {
            let current = '';
            document.querySelectorAll('.diagram-section').forEach(section => {
                const sectionTop = section.offsetTop;
                if (pageYOffset >= sectionTop - 100) {
                    current = section.getAttribute('id');
                }
            });

            document.querySelectorAll('nav a').forEach(link => {
                link.style.fontWeight = 'normal';
                link.style.background = 'transparent';
                if (link.getAttribute('href') === `#${current}`) {
                    link.style.fontWeight = 'bold';
                    link.style.background = '#f0f0f0';
                }
            });
        });
    </script>
</body>
</html>
